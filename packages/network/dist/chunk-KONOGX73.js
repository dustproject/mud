var L=(o=>(o.SystemCall="SystemCall",o.NetworkComponentUpdate="NetworkComponentUpdate",o))(L||{});function Oo(e){return e.type==="SystemCall"}function Q(e){return e.type==="NetworkComponentUpdate"}var mt=(p=>(p[p.BOOL=0]="BOOL",p[p.INT8=1]="INT8",p[p.INT16=2]="INT16",p[p.INT32=3]="INT32",p[p.INT64=4]="INT64",p[p.INT128=5]="INT128",p[p.INT256=6]="INT256",p[p.INT=7]="INT",p[p.UINT8=8]="UINT8",p[p.UINT16=9]="UINT16",p[p.UINT32=10]="UINT32",p[p.UINT64=11]="UINT64",p[p.UINT128=12]="UINT128",p[p.UINT256=13]="UINT256",p[p.BYTES=14]="BYTES",p[p.STRING=15]="STRING",p[p.ADDRESS=16]="ADDRESS",p[p.BYTES4=17]="BYTES4",p[p.BOOL_ARRAY=18]="BOOL_ARRAY",p[p.INT8_ARRAY=19]="INT8_ARRAY",p[p.INT16_ARRAY=20]="INT16_ARRAY",p[p.INT32_ARRAY=21]="INT32_ARRAY",p[p.INT64_ARRAY=22]="INT64_ARRAY",p[p.INT128_ARRAY=23]="INT128_ARRAY",p[p.INT256_ARRAY=24]="INT256_ARRAY",p[p.INT_ARRAY=25]="INT_ARRAY",p[p.UINT8_ARRAY=26]="UINT8_ARRAY",p[p.UINT16_ARRAY=27]="UINT16_ARRAY",p[p.UINT32_ARRAY=28]="UINT32_ARRAY",p[p.UINT64_ARRAY=29]="UINT64_ARRAY",p[p.UINT128_ARRAY=30]="UINT128_ARRAY",p[p.UINT256_ARRAY=31]="UINT256_ARRAY",p[p.BYTES_ARRAY=32]="BYTES_ARRAY",p[p.STRING_ARRAY=33]="STRING_ARRAY",p))(mt||{}),$o={[0]:"bool",[1]:"int8",[2]:"int16",[3]:"int32",[4]:"int64",[5]:"int128",[6]:"int256",[7]:"int",[8]:"uint8",[9]:"uint16",[10]:"uint32",[11]:"uint64",[12]:"uint128",[13]:"uint256",[14]:"bytes",[15]:"string",[16]:"address",[17]:"bytes4",[18]:"bool[]",[19]:"int8[]",[20]:"int16[]",[21]:"int32[]",[22]:"int64[]",[23]:"int128[]",[24]:"int256[]",[25]:"int[]",[26]:"uint8[]",[27]:"uint16[]",[28]:"uint32[]",[29]:"uint64[]",[30]:"uint128[]",[31]:"uint256[]",[32]:"bytes[]",[33]:"string[]"},Mo={[18]:0,[19]:1,[20]:2,[21]:3,[22]:4,[23]:5,[24]:6,[25]:7,[26]:8,[27]:9,[28]:10,[29]:11,[30]:12,[31]:6,[32]:14,[33]:15};import{Formatter as lt}from"@ethersproject/providers";import{callWithRetry as q,extractEncodedArguments as dt,range as be,sleep as ge}from"@latticexyz/utils";import{BigNumber as pt,Contract as ut}from"ethers";import{resolveProperties as Tt,defaultAbiCoder as ft}from"ethers/lib/utils.js";async function he(e,t){await q(()=>Promise.all([e.getBlockNumber(),t?t.getBlockNumber():Promise.resolve()]),[],10,1e3)}async function Zo(e,t){for(let o of be(10)){let a=await q(async()=>{let l=await e.perform("getBlock",{includeTransactions:!1,blockTag:e.formatter.blockTag(await e._getBlockTag("latest"))});return e.formatter.block(l)},[],10,1e3);if(t&&a.number<t){await ge(300);continue}else return a}throw new Error("Could not fetch a block with blockNumber "+t)}async function bt(e,t,o,n,a,l){let r=async(i,m)=>{let T=await Tt({filter:e._getFilter({fromBlock:o,toBlock:n,address:i,topics:m})}),f=await e.perform("getLogs",T);return f.forEach(b=>{b.removed==null&&(b.removed=!1)}),lt.arrayOf(e.formatter.filterLog.bind(e.formatter))(f)},u=async()=>{let i=await e.perform("getBlockNumber",{});return pt.from(i).toNumber()},d=()=>{let i=[];for(let[m,T]of Object.entries(a)){let f=t.find(b=>b.key===m)?.topics;f&&i.push(r(T.address,f))}return i};if(l){for(let i in be(10)){let m=()=>Promise.all([u(),...d()]),[T,f]=await q(m,[],10,1e3);if(T<l)await ge(500);else return f.flat()}throw new Error("Could not fetch logs with a required minimum block number")}else return(await q(()=>Promise.all([...d()]),[],10,1e3)).flat()}async function en(e,t,o,n,a,l){let r=await bt(e,t,o,n,a,l?n:void 0);r.sort((i,m)=>i.blockNumber<m.blockNumber?-1:i.blockNumber>m.blockNumber?1:i.transactionIndex<m.transactionIndex?-1:i.transactionIndex>m.transactionIndex?1:i.logIndex<m.logIndex?-1:1);let u={};for(let i of Object.keys(a))u[a[i].address.toLowerCase()]=i;let d=[];for(let i=0;i<r.length;i++){let m=r[i],T=u[m.address.toLowerCase()];if(!T)throw new Error("This should not happen. An event's address is not part of the contracts dictionnary: "+m.address);let{address:f,abi:b}=a[T],g=new ut(f,b);try{let y=g.interface.parseLog(m),h=r[i+1]?.transactionHash!==m.transactionHash;d.push({contractKey:T,eventKey:y.name,args:y.args,txHash:m.transactionHash,lastEventInTx:h,blockNumber:m.blockNumber,logIndex:m.logIndex})}catch(y){console.warn("Error",y),console.warn("A log couldn't be parsed with the corresponding contract interface!")}}return d}async function tn(e,t){let o=await t.getTransaction(e);if(!o)throw new Error("This transaction doesn't exist. Can't get the revert reason");o.gasPrice=void 0;let n=await t.call(o);return ft.decode(["string"],dt(n))[0]}import{Web3Provider as yt,WebSocketProvider as St}from"@ethersproject/providers";import{callWithRetry as Nt,observableToComputed as ye,timeoutAfter as It}from"@latticexyz/utils";import{observable as Se,reaction as Ne,runInAction as Ie}from"mobx";import{JsonRpcBatchProvider as gt,JsonRpcProvider as ht}from"@ethersproject/providers";var X=class extends ht{constructor(t,o){super(t,o)}async detectNetwork(){let t=this.network;if(t==null)throw new Error("No network");return t}},Z=class extends gt{constructor(t,o){super(t,o)}async detectNetwork(){let t=this.network;if(t==null)throw new Error("No network");return t}};function Ct({chainId:e,jsonRpcUrl:t,wsRpcUrl:o,externalProvider:n,options:a}){let l={chainId:e,name:"mudChain"},r=n?{json:new yt(n,l),ws:void 0}:{json:a?.batch?new Z(t,l):new X(t,l),ws:o?new St(o,l):void 0};return a?.pollingInterval&&(r.json.pollingInterval=a.pollingInterval),r}var kt=(n=>(n[n.DISCONNECTED=0]="DISCONNECTED",n[n.CONNECTING=1]="CONNECTING",n[n.CONNECTED=2]="CONNECTED",n))(kt||{});async function Ce(e){let t=Se.box(0),o=Se.box(),n=[];async function a(){if(t.get()===1)return;Ie(()=>t.set(1));let r=o.get();r?.json.removeAllListeners(),r?.ws?.removeAllListeners();try{r?.ws?._websocket?.close()}catch{}let u=e.get();await Nt(async()=>{let d=Ct(u);!u?.options?.skipNetworkCheck&&await he(d.json,d.ws),Ie(()=>{o.set(d),t.set(2)})})}n.push(Ne(()=>e.get(),()=>a())),n.push(Ne(()=>o.get(),r=>{r?.ws?._websocket&&(r.ws._websocket.onerror=a,r.ws._websocket.onclose=()=>{t.get()===2&&a()})}));let l=setInterval(async()=>{if(t.get()!==2)return;let r=o.get();if(r?.ws)try{await It(r.ws.getBlockNumber(),1e4,"Network Request Timed out")}catch{a()}},1e4);return n.push(()=>clearInterval(l)),await a(),{connected:ye(t),providers:ye(o),dispose:()=>{for(let r of n)r();try{o.get()?.ws?._websocket?.close()}catch{}}}}import{stretch as wt}from"@latticexyz/utils";import{reaction as xt}from"mobx";import{concat as Et,concatMap as vt,EMPTY as Rt,endWith as At,filter as Ut,map as Bt,range as Yt,ReplaySubject as Pt,take as Lt}from"rxjs";function ke(e,t){let o=new Pt(1),n=t?.initialSync?o.pipe(Lt(1),Ut(r=>r>(t.initialSync.initialBlockNumber||0)),vt(r=>{let u=r-t.initialSync.initialBlockNumber;return Yt(0,Math.ceil(u/t.initialSync.interval)).pipe(Bt(d=>t.initialSync.initialBlockNumber+d*t.initialSync.interval),At(r))}),wt(50)):Rt,a=xt(()=>e.get(),r=>{let u=r?.ws||r?.json,d=!0;u?.getBlockNumber().then(i=>{d&&o.next(i)}),u?.on("block",i=>{d=!1,o.next(i)})},{fireImmediately:!0});return{blockNumber$:Et(n,o),dispose:a}}import{BehaviorSubject as ee,Subject as we}from"rxjs";var K=new we,Cn=new we,kn=new ee(null),wn=new ee(null),se=new ee(null),xe=new ee(null);import{packTuple as Dt,transformIterator as _t,unpackTuple as Ot}from"@latticexyz/utils";import Vt from"debug";var ve=Vt("mud:network");var te=ve.extend("workers");import{Subject as Re}from"rxjs";var $t=te.extend("CacheStore");function Mt(e,t,o){return`${e}-${t}-${o}`}function V(){let e=[],t=new Map,o=[],n=new Map,a=0,l=new Map,r=new Re;return{components:e,componentToIndex:t,entities:o,entityToIndex:n,blockNumber:a,state:l,componentUpdate$:r,keys:{},tables:{}}}function D(e,{component:t,entity:o,value:n,partialValue:a,initialValue:l,blockNumber:r,key:u,namespace:d,table:i}){let{components:m,entities:T,componentToIndex:f,entityToIndex:b,state:g,keys:y,tables:h}=e,N=f.get(t);N==null&&(N=m.push(t)-1,f.set(t,N));let I=b.get(o);I==null&&(I=T.push(o)-1,b.set(o,I)),u&&(y[I]=u),d!=null&&i!=null&&(h[N]={namespace:d,table:i});let k=Dt([N,I]);if(a!==void 0){let M=g.get(k);g.set(k,{...l,...M,...a})}else n===void 0?(console.log("deleting key",k),g.delete(k)):g.set(k,n);e.blockNumber=r-1,e.componentUpdate$.next({component:t,entity:o,blockNumber:r})}function ce(e,t){for(let o of t)D(e,o)}function ie({blockNumber:e,state:t,components:o,entities:n,keys:a,tables:l}){return _t(t.entries(),([r,u])=>{let[d,i]=Ot(r),m=o[d],T=n[i],f=a[i],{namespace:b,table:g}=l[d];if(m==null||T==null)throw new Error(`Unknown component / entity: ${m}, ${T}`);return{type:"NetworkComponentUpdate",component:m,entity:T,value:u,namespace:b,table:g,key:f,lastEventInTx:!1,txHash:"cache",blockNumber:e}})}function Ln(e){let t=V(),o=[...e].sort((n,a)=>n.blockNumber-a.blockNumber);for(let n of o)for(let a of ie(n))D(t,a);return t.blockNumber=o[o.length-1].blockNumber,t}async function me(e,t){$t("store cache with size",t.state.size,"at block",t.blockNumber),await e.set("ComponentValues","current",t.state),await e.set("Mappings","components",t.components),await e.set("Mappings","entities",t.entities),await e.set("BlockNumber","current",t.blockNumber),await e.set("Keys","current",t.keys),await e.set("Tables","current",t.tables)}async function Ae(e){let t=await e.get("ComponentValues","current")??new Map,o=await e.get("BlockNumber","current")??0,n=await e.get("Mappings","components")??[],a=await e.get("Mappings","entities")??[],l=await e.get("Keys","current")??{},r=await e.get("Tables","current")??{},u=new Map,d=new Map,i=new Re;for(let m=0;m<n.length;m++)u.set(n[m],m);for(let m=0;m<a.length;m++)d.set(a[m],m);return{state:t,blockNumber:o,components:n,entities:a,componentToIndex:u,entityToIndex:d,componentUpdate$:i,keys:l,tables:r}}async function Ue(e){return await e.get("BlockNumber","current")??0}async function Be(e,t,o,n){let{initCache:a}=await import("./initCache-EWNWDC2L.js");return a(Mt("ECSCache",e,t),["ComponentValues","BlockNumber","Mappings","Snapshot","Keys","Tables"],o,n)}import{pad as Ft}from"viem";var Ye=(n=>(n[n.CONNECTING=0]="CONNECTING",n[n.INITIAL=1]="INITIAL",n[n.LIVE=2]="LIVE",n))(Ye||{}),j=Ft("0x060d",{size:32}),On=j;import{awaitStreamValue as Io,filterNullish as Co,keccak256 as ko,streamToDefinedComputed as wo}from"@latticexyz/utils";import{bufferTime as xo,concat as Eo,concatMap as vo,filter as at,ignoreElements as Ro,map as Ao,of as Uo,Subject as fe,take as Bo}from"rxjs";import{computed as Yo}from"mobx";import He from"lodash/orderBy";import{isDefined as Ke}from"@latticexyz/common/utils";import{TableId as Pe}from"@latticexyz/common";var oe=new Pe("mudstore","schema"),Y=new Pe("mudstore","StoreMetadata"),Le=["StoreSetRecord","StoreSetField","StoreDeleteRecord"],Ve=["StoreEphemeralRecord"];import{TableId as lo}from"@latticexyz/common";import{TableId as Oe}from"@latticexyz/common";import{utils as ao}from"ethers";import{getStaticByteLength as Ht,SchemaTypeToAbiType as Kt}from"@latticexyz/schema-type/deprecated";import{hexToArray as jt}from"@latticexyz/utils";function le(e){let t=!e||e==="0x",o=t?new Uint8Array(64).buffer:jt(e).buffer,n=new DataView(o),a=new DataView(o.slice(32)),l={...De(n),rawSchema:e,isEmpty:t},r={...De(a),rawSchema:e,isEmpty:t};return{valueSchema:l,keySchema:r}}function De(e){let t=e.getUint16(0),o=e.getUint8(2),n=e.getUint8(3),a=[],l=[];for(let i=4;i<4+o;i++)a.push(e.getUint8(i));for(let i=4+o;i<4+o+n;i++)l.push(e.getUint8(i));let r=a.reduce((i,m)=>i+Ht(m),0);if(r!==t)throw console.error("Schema static data length mismatch! Is `getStaticByteLength` outdated?",{schemaStaticDataLength:t,actualStaticDataLength:r,schemaBytes:e}),new Error("Schema static data length mismatch! Is `getStaticByteLength` outdated?");let d=`(${[...a,...l].map(i=>Kt[i]).join(",")})`;return{staticDataLength:t,staticFields:a,dynamicFields:l,abi:d}}var de={};function v(e,t,o){let n=`${e.address}:${t.toHex()}`,a=de[n];if(a)return o&&a.then(m=>{m.valueSchema.rawSchema!==o&&console.warn("a different schema was already registered for this table",{table:t,currentSchema:m,newSchema:o,world:e.address})}),a;if(o){console.log("registering schema for table",{table:t.toString(),world:e.address,rawSchema:o});let m=Promise.resolve(le(o));return de[n]=m,m}console.log("fetching schema for table",{table:t.toString(),world:e.address});let l=e,r=l.getKeySchema(t.toHex()),u=l.getSchema(t.toHex()),i=Promise.all([r,u]).then(([m,T])=>T+m.substring(2)).then(m=>{let T=le(m);return T.valueSchema.isEmpty&&console.warn("Schema not found for table",{table:t.toString(),world:e.address}),T});return de[n]=i,i}import{utils as oo}from"ethers";import{getStaticByteLength as ue,SchemaType as _e}from"@latticexyz/schema-type/deprecated";import{hexToArray as to}from"@latticexyz/utils";import{getStaticByteLength as Wt,SchemaType as s}from"@latticexyz/schema-type/deprecated";import{toHex as Gt,pad as zt}from"viem";var Jt=e=>{throw new Error(`Unsupported static field type: ${s[e]??e}`)},x=(e,t,o)=>{let n=Wt(e),a=t.slice(o,o+n),l=Gt(a),r=l.replace(/^0x$/,"0x0");switch(e){case s.BOOL:return Number(r)!==0;case s.UINT8:case s.UINT16:case s.UINT24:case s.UINT32:case s.UINT40:case s.UINT48:return Number(r);case s.UINT56:case s.UINT64:case s.UINT72:case s.UINT80:case s.UINT88:case s.UINT96:case s.UINT104:case s.UINT112:case s.UINT120:case s.UINT128:case s.UINT136:case s.UINT144:case s.UINT152:case s.UINT160:case s.UINT168:case s.UINT176:case s.UINT184:case s.UINT192:case s.UINT200:case s.UINT208:case s.UINT216:case s.UINT224:case s.UINT232:case s.UINT240:case s.UINT248:case s.UINT256:return BigInt(r);case s.INT8:case s.INT16:case s.INT24:case s.INT32:case s.INT40:case s.INT48:{let u=2**(n*8),d=Number(r);return d<u/2?d:d-u}case s.INT56:case s.INT64:case s.INT72:case s.INT80:case s.INT88:case s.INT96:case s.INT104:case s.INT112:case s.INT120:case s.INT128:case s.INT136:case s.INT144:case s.INT152:case s.INT160:case s.INT168:case s.INT176:case s.INT184:case s.INT192:case s.INT200:case s.INT208:case s.INT216:case s.INT224:case s.INT232:case s.INT240:case s.INT248:case s.INT256:{let u=2n**(BigInt(n)*8n),d=BigInt(r);return d<u/2n?d:d-u}case s.BYTES1:case s.BYTES2:case s.BYTES3:case s.BYTES4:case s.BYTES5:case s.BYTES6:case s.BYTES7:case s.BYTES8:case s.BYTES9:case s.BYTES10:case s.BYTES11:case s.BYTES12:case s.BYTES13:case s.BYTES14:case s.BYTES15:case s.BYTES16:case s.BYTES17:case s.BYTES18:case s.BYTES19:case s.BYTES20:case s.BYTES21:case s.BYTES22:case s.BYTES23:case s.BYTES24:case s.BYTES25:case s.BYTES26:case s.BYTES27:case s.BYTES28:case s.BYTES29:case s.BYTES30:case s.BYTES31:case s.BYTES32:case s.ADDRESS:return zt(l,{dir:"right",size:n});default:return Jt(e)}};import{SchemaType as pe,SchemaTypeArrayToElement as Qt,getStaticByteLength as qt}from"@latticexyz/schema-type/deprecated";import{toHex as Xt,bytesToString as Zt}from"viem";var eo=e=>{throw new Error(`Unsupported dynamic field type: ${pe[e]??e}`)},A=(e,t)=>{if(e===pe.BYTES)return Xt(t);if(e===pe.STRING)return Zt(t);let o=Qt[e];if(o!==void 0){let n=qt(o),a=t.byteLength/n;return new Array(a).fill(void 0).map((l,r)=>x(o,t,r*n))}return eo(e)};var ne=(e,t)=>{let o={},n=to(t),a=0;e.staticFields.forEach((r,u)=>{let d=x(r,n,a);a+=ue(r),o[u]=d});let l=a;if(l!==e.staticDataLength&&console.warn("Decoded static data length does not match schema's expected static data length. Data may get corrupted. Is `getStaticByteLength` outdated?",{expectedLength:e.staticDataLength,actualLength:l,bytesOffset:a,schema:e,hexData:t}),e.dynamicFields.length>0){let r=n.slice(e.staticDataLength,e.staticDataLength+32);a+=32;let u=_e.UINT56,d=_e.UINT40,i=x(u,r,0);e.dynamicFields.forEach((T,f)=>{let b=x(d,r,ue(u)+f*ue(d)),g=A(T,n.slice(a,a+b));a+=b,o[e.staticFields.length+f]=g});let m=a-32-l;BigInt(m)!==i&&console.warn("Decoded dynamic data length does not match data layout's expected data length. Data may get corrupted. Did the data layout change?",{expectedLength:i,actualLength:m,bytesOffset:a,schema:e,hexData:t})}return o};var Te={};function P(e,t,o){let n=`${e.address}:${t.toHex()}`,a=Te[n];if(a)return o&&a.then(r=>{JSON.stringify(r)!==JSON.stringify(o)&&console.warn("different metadata already registered for this table",{table:t,currentMetadata:r,newMetadata:o,world:e.address})}),a;if(o){console.log("registering metadata for table",{table:t.toString(),metadata:o,world:e.address});let r=Promise.resolve(o);return Te[n]=r,r}if(t.toHex()===oe.toHex()||t.toHex()===Y.toHex())return Promise.resolve(void 0);console.log("fetching metadata for table",{table:t.toString(),world:e.address});let l=Promise.all([v(e,Y),e["getRecord(bytes32,bytes32[])"](Y.toHex(),[t.toHex()])]).then(([{valueSchema:r},u])=>{r.isEmpty&&console.warn("Metadata schema not found",{table:Y.toString(),world:e.address}),(!u||u==="0x")&&console.warn("Metadata not found for table",{table:t.toString(),world:e.address});let d=ne(r,u),i=d[0];i!==t.name&&console.warn("Metadata table name does not match table ID",{tableName:i,tableId:t.toString(),world:e.address});let[m]=oo.defaultAbiCoder.decode(["string[]"],d[1]);return{tableName:i,fieldNames:m}});return Te[n]=l,l}import{SchemaTypeToAbiType as no}from"@latticexyz/schema-type/deprecated";import{decodeAbiParameters as ro}from"viem";function _(e,t){let o=e.staticFields.map(a=>no[a]);return t.map((a,l)=>ro([{type:o[l]}],a)[0]).reduce((a,l,r)=>({...a,[r]:l}),{})}async function W(e,t,o,n){if(t.toHex()===oe.toHex()){let[i,...m]=o;m.length&&console.warn("registerSchema event has more than one value in key tuple, but this method only supports a single key",{table:t,keyTuple:o}),v(e,Oe.fromHex(i),n)}let{keySchema:a,valueSchema:l}=await v(e,t),r=ne(l,n),u=_(a,o);if(t.toHex()===Y.toHex()){let[i,...m]=o;m.length&&console.warn("setMetadata event has more than one value in key tuple, but this method only supports a single key",{table:t,keyTuple:o});let T=r[0],[f]=ao.defaultAbiCoder.decode(["string[]"],r[1]);P(e,Oe.fromHex(i),{tableName:T,fieldNames:f})}let d=await P(e,t);if(d){let{tableName:i,fieldNames:m}=d,T={};for(let[f,b]of m.entries())T[b]=r[f];return{indexedValues:r,namedValues:T,indexedKey:u}}return console.warn(`Received data for ${t.toString()}, but could not find table metadata for field names. Did your contracts get autogenerated and deployed properly?`),{indexedValues:r,indexedKey:u}}import{hexToArray as so}from"@latticexyz/utils";var $e=(e,t,o)=>{let n={},a=so(o);return e.staticFields.forEach((l,r)=>{r===t&&(n[t]=x(l,a,0))}),e.dynamicFields.length>0&&e.dynamicFields.forEach((l,r)=>{e.staticFields.length+r===t&&(n[t]=A(l,a))}),n};async function Me(e,t,o,n,a){let l=await v(e,t),{valueSchema:r,keySchema:u}=l,d=$e(r,n,a),i=_(u,o),m=[...r.staticFields.map(b=>x(b,new Uint8Array(0),0)),...r.dynamicFields.map(b=>A(b,new Uint8Array(0)))],T=Object.fromEntries(m.map((b,g)=>[g,b])),f=await P(e,t);if(f){let{tableName:b,fieldNames:g}=f,y=Object.fromEntries(m.map((h,N)=>[g[N],h]));return{schema:l,indexedValues:d,indexedInitialValues:T,namedValues:{[g[n]]:d[n]},namedInitialValues:y,indexedKey:i}}return console.warn(`Received data for ${t.toString()}, but could not find table metadata for field names. Did your contracts get autogenerated and deployed properly?`),{schema:l,indexedValues:d,indexedInitialValues:T,indexedKey:i}}import{toHex as co,pad as io,isHex as mo}from"viem";function O(e){return e.length===0?j:e.map(t=>mo(t)?io(t,{size:32}):co(t,{size:32})).join(":")}var Fe=async(e,t,o,n,a)=>{let{blockNumber:l,transactionHash:r,logIndex:u}=o,{args:d,name:i}=n,m=lo.fromHex(d.table),T=m.toString(),f=O(d.key),b={type:"NetworkComponentUpdate",component:T,entity:f,value:void 0,blockNumber:l,txHash:r,logIndex:u,lastEventInTx:a,namespace:m.namespace,table:m.name,key:{}};if(i==="StoreSetRecord"){let{indexedValues:g,namedValues:y,indexedKey:h,namedKey:N}=await W(t,m,d.key,d.data);return{...b,value:{...g,...y},key:{...h,...N},devEmit:()=>{K.next({event:i,chainId:e,worldAddress:t.address,blockNumber:l,logIndex:u,transactionHash:r,table:m,keyTuple:d.key,indexedValues:g,namedValues:y})}}}if(i==="StoreEphemeralRecord"){let{indexedValues:g,namedValues:y,indexedKey:h,namedKey:N}=await W(t,m,d.key,d.data);return{...b,ephemeral:!0,value:{...g,...y},key:{...h,...N},devEmit:()=>{K.next({event:i,chainId:e,worldAddress:t.address,blockNumber:l,logIndex:u,transactionHash:r,table:m,keyTuple:d.key,indexedValues:g,namedValues:y})}}}if(i==="StoreSetField"){console.log("set field");let{indexedValues:g,indexedInitialValues:y,namedValues:h,namedInitialValues:N,indexedKey:I,namedKey:k}=await Me(t,m,d.key,d.schemaIndex,d.data);return{...b,partialValue:{...g,...h},initialValue:{...y,...N},key:{...I,...k},devEmit:()=>{K.next({event:i,chainId:e,worldAddress:t.address,blockNumber:l,logIndex:u,transactionHash:r,table:m,keyTuple:d.key,indexedValues:g,namedValues:h})}}}if(i==="StoreDeleteRecord"){let{keySchema:g}=await v(t,m),y=_(g,d.key);return{...b,key:y,devEmit:()=>{K.next({event:i,chainId:e,worldAddress:t.address,blockNumber:l,logIndex:u,transactionHash:r,table:m,keyTuple:d.key})}}}};async function je(e,t,o){let{chainId:n}=await e.provider.getNetwork(),l=[...Le,...Ve].map(T=>e.filters[T]().topics).filter(Ke),r=await Promise.all(l.map(T=>e.provider.getLogs({address:e.address,topics:T,fromBlock:t,toBlock:o}))),u=He(r.flatMap(T=>T.map(f=>({log:f,parsedLog:e.interface.parseLog(f)}))),["log.blockNumber","log.logIndex"]),d={};u.map(({log:T})=>{d[T.transactionHash]=T.logIndex});let i=await Promise.all(u.map(({log:T,parsedLog:f})=>{let{transactionHash:b,logIndex:g}=T;return Fe(n,e,T,f,d[b]===g)})),m=He(i.filter(Ke),["blockNumber","logIndex"]);return m.forEach(T=>T?.devEmit&&T.devEmit()),m}import Po from"@latticexyz/store/abi/IStore.sol/IStore.abi.json";import{Contract as Lo}from"ethers";import{QueryLayerDefinition as po}from"@latticexyz/services/mode";import{createChannel as uo,createClient as To}from"nice-grpc-web";function We(e){return To(po,uo(e))}import{AbiTypeToSchemaType as ze,encodeSchema as Je}from"@latticexyz/schema-type/deprecated";import{arrayToHex as ae}from"@latticexyz/utils";import{TableId as bo}from"@latticexyz/common";import{SchemaType as fo}from"@latticexyz/schema-type/deprecated";import{SchemaType as c}from"@latticexyz/schema-type/deprecated";function Ge(e,t){switch(e){case c.BOOL:case c.UINT8:case c.UINT16:case c.UINT24:case c.UINT32:case c.UINT40:case c.UINT48:case c.UINT56:case c.UINT64:case c.UINT72:case c.UINT80:case c.UINT88:case c.UINT96:case c.UINT104:case c.UINT112:case c.UINT120:case c.UINT128:case c.UINT136:case c.UINT144:case c.UINT152:case c.UINT160:case c.UINT168:case c.UINT176:case c.UINT184:case c.UINT192:case c.UINT200:case c.UINT208:case c.UINT216:case c.UINT224:case c.UINT232:case c.UINT240:case c.UINT248:case c.UINT256:case c.INT8:case c.INT16:case c.INT24:case c.INT32:case c.INT40:case c.INT48:case c.INT56:case c.INT64:case c.INT72:case c.INT80:case c.INT88:case c.INT96:case c.INT104:case c.INT112:case c.INT120:case c.INT128:case c.INT136:case c.INT144:case c.INT152:case c.INT160:case c.INT168:case c.INT176:case c.INT184:case c.INT192:case c.INT200:case c.INT208:case c.INT216:case c.INT224:case c.INT232:case c.INT240:case c.INT248:case c.INT256:case c.BYTES1:case c.BYTES2:case c.BYTES3:case c.BYTES4:case c.BYTES5:case c.BYTES6:case c.BYTES7:case c.BYTES8:case c.BYTES9:case c.BYTES10:case c.BYTES11:case c.BYTES12:case c.BYTES13:case c.BYTES14:case c.BYTES15:case c.BYTES16:case c.BYTES17:case c.BYTES18:case c.BYTES19:case c.BYTES20:case c.BYTES21:case c.BYTES22:case c.BYTES23:case c.BYTES24:case c.BYTES25:case c.BYTES26:case c.BYTES27:case c.BYTES28:case c.BYTES29:case c.BYTES30:case c.BYTES31:case c.BYTES32:case c.ADDRESS:return x(e,t,0);default:return A(e,t)}}function re(e){if(e.cols[1]!=="block_number")throw new Error("Table does not contain block_number column");return Number(Ge(fo.UINT256,e.rows[0].values[1]))}import{decodeAbiParameters as Qe}from"viem";async function qe(e,t,o,n){let a=V(),l=await e.getState({chainTables:[],worldTables:[],namespace:{chainId:t.toString(),worldAddress:o.address}});console.log("syncTablesFromMode",l);let r=Object.values(l.worldTables).reduce((m,T)=>m+T.rows.length,0),u=0,d=re(l.chainTables.block_number),i=[];for(let[m,{rows:T,cols:f,types:b}]of Object.entries(l.worldTables)){let[g,y]=m.split("__"),h=new bo(g,y),N=h.toString(),I=f.findIndex(C=>!C.startsWith("key_")),k=b.slice(0,I),M=k.map(C=>ze[C]),G=ae(Je(M)),z=f.slice(I),U=b.slice(I).map(C=>C.match(/tuple\((.*)\[]\)/)?.[1]??C),J=U.map(C=>ze[C]),w=ae(Je(J))+G.substring(2);i.push(v(o,h,w)),i.push(P(o,h,{tableName:y,fieldNames:z}));for(let C of T){console.log(y,k,U,C.values);let F=C.values.slice(0,I).map((B,p)=>Qe([{type:k[p]}],ae(B))[0]),H=C.values.slice(I).map((B,p)=>Qe([{type:U[p]}],ae(B))[0]),S=F.reduce((B,p,it)=>({...B,[it]:p}),{}),E=O(F),ct=Object.fromEntries(H.map((B,p)=>[z[p],B]));D(a,{type:"NetworkComponentUpdate",component:N,entity:E,key:S,value:ct,blockNumber:d,namespace:h.namespace,table:h.name}),u++,u%100===0&&n&&n(Math.floor(u/r))}console.log("done syncing from mode table",y)}return console.log("done syncing from mode",u,"rows processed"),await Promise.all(i),a}async function Xe(e,t){try{let o=await e.getPartialState({table:"block_number",namespace:{chainId:t.toString()}});return re(o.chainTables.block_number)}catch(o){return console.error("MODE Error: ",o),-1}}import{TableId as Ze}from"@latticexyz/common";async function et(e,t,o){let n=[];for(let a of t){let{tableId:l,keyTuple:r,value:u}=a,d=Ze.fromHex(Ze.toHex(l.namespace,l.name)),{indexedValues:i,namedValues:m,indexedKey:T,namedKey:f}=await W(e,d,r,u),b={...T,...f},g=d.toString(),y=O(r),h={type:"NetworkComponentUpdate",component:g,entity:y,key:b,value:{...i,...m},lastEventInTx:!1,txHash:"cache",blockNumber:o,namespace:l.namespace,table:l.name};n.push(h)}return n}import{getEventSelector as Vo}from"viem";import{concatMap as go,map as ho,of as yo}from"rxjs";import{orderBy as tt}from"lodash";import ot from"debug";import{awaitPromise as So,range as No}from"@latticexyz/utils";function nt(e,t){let o;return e.pipe(ho(async n=>{let a=o==null||o>=n?n:o+1,l=n;o=l;let r=await t(a,l),u=tt(r,["blockNumber","logIndex"]);return ot(`fetched ${u.length} events from block range ${a} -> ${l}`),u}),So(),go(n=>yo(...n)))}async function rt(e,t,o,n=50,a){let l=[],r=o-t,u=Math.ceil(r/n),d=[...No(u,n,t)];for(let i=0;i<d.length;i++){let m=d[i],T=i===d.length-1?o:d[i+1]-1,f=await e(m,T);a&&a(i*n/r*100),ot(`initial sync fetched ${l.length} events from block range ${m} -> ${T}`),l=l.concat(tt(f,["blockNumber","logIndex"]))}return l}var $=te.extend("SyncWorker"),Do=3,_o=(o=>(o[o.Ack=0]="Ack",o[o.Config=1]="Config",o))(_o||{}),Ts={type:0},st=class{input$=new fe;output$=new fe;syncState={state:0,msg:"",percentage:0};constructor(){$("creating SyncWorker"),this.init()}setLoadingState(t,o=0){let n={...this.syncState,...t};this.syncState=n;let a={type:"NetworkComponentUpdate",component:ko("component.LoadingState"),value:n,entity:j,key:{},namespace:"mudsync",table:"LoadingState",txHash:"worker",lastEventInTx:!1,blockNumber:o};this.output$.next(a)}async init(){this.setLoadingState({state:0,msg:"Connecting...",percentage:0});let t=await wo(this.input$.pipe(Ao(S=>S.type===1?S.data:void 0),Co())),o=t.get(),{modeUrl:n,chainId:a,worldContract:l,disableCache:r,initialRecords:u,showInDevTools:d}=o;d&&xe.next(l.address);let i=o.cacheAgeThreshold||100,m=o.cacheInterval||1,{providers:T}=await Ce(Yo(()=>t.get().provider)),f=T.get().json,b=n?We(n):void 0,g=await Be(a,l.address,Do);$("start initial sync"),this.setLoadingState({state:1,msg:"Starting initial sync",percentage:0});let y=!1,h={current:V()};d&&se.next(h.current);let{blockNumber$:N}=ke(T),I=new Lo(l.address,Po,f),k=(S,E)=>je(I,S,E),M=nt(N,k),G=[];M.subscribe(S=>{if(!y){Q(S)&&G.push(S);return}Q(S)&&(D(h.current,S),S.blockNumber>h.current.blockNumber+1&&S.blockNumber%m===0&&me(g,h.current));let E=S;Q(E)&&delete E.devEmit,this.output$.next(E)});let z=Io(N);this.setLoadingState({state:1,msg:"Fetching cache block number",percentage:0});let U=r?-1:await Ue(g);this.setLoadingState({percentage:50});let J=b?await Xe(b,a):-1,R=o.initialBlockNumber;if(R<0){let S=await f.getLogs({address:l.address,topics:[Vo("event HelloWorld()")],fromBlock:"earliest"});R=S.length>0?S[0].blockNumber:0}this.setLoadingState({percentage:100}),$(`cache block: ${U}, start sync at ${R}`);let w=V();if(u){console.log("Initial state from pre-loaded records"),this.setLoadingState({state:1,msg:"Loading initial state",percentage:0});let S=await et(I,u,R);ce(w,S),w.blockNumber=R}else if(R>Math.max(U,J))w.blockNumber=R;else{let S=b&&J>U+i;console.log("syncFromMode",S),S?(console.log("Initial sync from MODE"),this.setLoadingState({state:1,msg:"Fetching initial state from MODE",percentage:0}),w=await qe(b,a,I,E=>this.setLoadingState({percentage:E})),this.setLoadingState({percentage:100})):r||(this.setLoadingState({state:1,msg:"Fetching initial state from cache",percentage:0}),w=await Ae(g),this.setLoadingState({percentage:100})),$(`got ${w.state.size} items from ${S?"mode":"cache"}`)}let C=await z;this.setLoadingState({state:1,msg:`Fetching state from block ${w.blockNumber} to ${C}`,percentage:0});let F=await rt(k,w.blockNumber,C,50,S=>this.setLoadingState({percentage:S}));$(`got ${F.length} items from block range ${w.blockNumber} -> ${C}`),ce(w,[...F,...G].filter(S=>!S.ephemeral)),h.current=w,d&&se.next(h.current),$(`initial sync state size: ${h.current.state.size}`),this.setLoadingState({state:1,msg:`Initializing with ${h.current.state.size} state entries`,percentage:0});let H=0;for(let S of ie(h.current))if(H++,this.output$.next(S),H%5e3===0){let E=Math.floor(H/h.current.state.size*100);this.setLoadingState({percentage:E})}me(g,h.current),this.setLoadingState({state:2,msg:"Streaming live events",percentage:100},h.current.blockNumber),y=!0}work(t){t.subscribe(this.input$);let o=new fe;return this.output$.pipe(xo(16,null,50),at(n=>n.length>0),vo(n=>Eo(Uo(n),t.pipe(at(a=>a.type===0),Bo(1),Ro())))).subscribe(o),o}};export{L as a,Oo as b,Q as c,mt as d,$o as e,Mo as f,he as g,Zo as h,bt as i,en as j,tn as k,Ct as l,kt as m,Ce as n,ke as o,K as p,Cn as q,kn as r,wn as s,se as t,xe as u,Mt as v,V as w,D as x,ce as y,ie as z,Ln as A,me as B,Ae as C,Ue as D,Be as E,Ye as F,j as G,On as H,O as I,_o as J,Ts as K,st as L};
//# sourceMappingURL=chunk-KONOGX73.js.map