<<<<<<< HEAD
import m from"fs";import i from"path";async function o(n){try{return await WebAssembly.compileStreaming(fetch(n))}catch{return WebAssembly.compile(m.readFileSync(n))}}function u(n,r,e){return r+n*(e-r)}function a(n,r){let e=n.findIndex(t=>t[0]>=r);if(e>0)return[n[e-1],n[e]];console.warn("out of reach",r,n)}function l(n){return r=>{let e=a(n,r);if(!e)return r;let t=(r-e[0][0])/(e[1][0]-e[0][0]);return u(t,e[0][1],e[1][1])}}async function p(){let n=await o(import.meta.url?new URL("../build/release.wasm",import.meta.url):i.resolve(__dirname,"../build/release.wasm"));return(await WebAssembly.instantiate(n,{env:{abort:e=>{throw new Error("abort called in wasm perlin: "+e)}}})).exports.perlin}export{p as createPerlin,l as createSplines,o as fetchAndCompileWasmModule,u as lerp};
=======
import m from"fs";import o from"path";async function i(n){try{return await WebAssembly.compileStreaming(fetch(n))}catch{return WebAssembly.compile(m.readFileSync(n))}}function u(n,r,e){return r+n*(e-r)}function a(n,r){let e=n.findIndex(t=>t[0]>=r);if(e>0)return[n[e-1],n[e]];console.warn("out of reach",r,n)}function l(n){return r=>{let e=a(n,r);if(!e)return r;let t=(r-e[0][0])/(e[1][0]-e[0][0]);return u(t,e[0][1],e[1][1])}}async function p(){let n=await i(import.meta.url?new URL("../build/release.wasm",import.meta.url):o.resolve(__dirname,"../build/release.wasm"));return(await WebAssembly.instantiate(n,{env:{abort:e=>{throw new Error("abort called in wasm perlin: "+e)}}})).exports.perlin}export{p as createPerlin,l as createSplines,i as fetchAndCompileWasmModule,u as lerp};
>>>>>>> a4f03cd4 (chore: export types)
//# sourceMappingURL=index.mjs.map