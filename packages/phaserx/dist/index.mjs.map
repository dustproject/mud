{"version":3,"sources":["../src/index.ts","../src/utils/tween.ts","../src/utils/math.ts","../src/utils/coords.ts","../src/utils/load.ts","../src/utils/chunks.ts","../src/utils/area.ts","../src/utils/generateFrames.ts","../src/pipelines/HueTintAndOutlineFXPipeline.ts","../src/pipelines/MultiHueTintPipeline.ts","../src/defineScene.ts","../src/definePhaserConfig.ts","../src/constants.ts","../src/createChunks.ts","../src/createCamera.ts","../src/createCulling.ts","../src/createEmbodiedEntity.ts","../src/guards.ts","../src/createObjectPool.ts","../src/tilemap/createChunkedTilemap.ts","../src/tilemap/createVirtualTilemap.ts","../src/tilemap/createAnimatedTilemap.ts","../src/createInput.ts","../src/createPhaserEngine.ts","../src/createDebugger.ts"],"sourcesContent":["import \"phaser\";\n\nexport * from \"./utils\";\nexport * from \"./createPhaserEngine\";\nexport * from \"./createObjectPool\";\nexport * from \"./definePhaserConfig\";\nexport * from \"./defineScene\";\nexport * from \"./createCamera\";\nexport * from \"./createChunks\";\nexport * from \"./createDebugger\";\nexport * from \"./createCulling\";\nexport * from \"./constants\";\nexport * from \"./guards\";\nexport * from \"./pipelines\";\nexport * from \"./tilemap\";\nexport * from \"./createInput\";\nexport type { Asset, Camera, Coord } from \"./types\";\nexport type { AnimatedTilemap, ChunkedTilemap, VirtualTilemap } from \"./tilemap\";\n","import { deferred } from \"@latticexyz/utils\";\n\ntype TweenBuilderConfig = { targets: Phaser.GameObjects.Sprite } & Omit<\n  Phaser.Types.Tweens.TweenBuilderConfig,\n  \"targets\"\n>;\n\n/**\n * Add a tween to the provided game object.\n * @returns Promise that resolves when the tween is done.\n */\nexport async function tween(config: TweenBuilderConfig, options?: { keepExistingTweens?: boolean }) {\n  const [resolve, , promise] = deferred<void>();\n  const { targets } = config;\n  if (!targets.scene || !targets.scene.tweens) return;\n\n  // Kill old tweens\n  if (!options?.keepExistingTweens) {\n    removeAllTweens(targets);\n  }\n\n  // Add new tween\n  targets.scene.tweens.add({\n    ...config,\n    onComplete: (tween, targets) => {\n      config.onComplete && config.onComplete(tween, targets);\n      resolve();\n    },\n  });\n  return promise;\n}\n\nexport function removeAllTweens(gameObject: Phaser.GameObjects.GameObject) {\n  const tweenManager = gameObject.scene.tweens;\n  for (const tween of tweenManager.tweens) {\n    if (tween.hasTarget(gameObject)) {\n      tween.stop();\n    }\n  }\n}\n","export function mod(a: number, b: number) {\n  return ((a % b) + b) % b;\n}\n","import { Area, ChunkCoord, Coord, PixelCoord, WorldCoord } from \"../types\";\n\nexport const ZERO_VECTOR: Coord = { x: 0, y: 0 };\n\nexport function cornerTileCoordsFromRegionCoords(regionCoords: WorldCoord[], regionLength: number) {\n  const tileCoords: WorldCoord[] = [];\n\n  regionCoords.forEach((regionCoord) => {\n    const topLeft = { x: regionCoord.x * regionLength, y: regionCoord.y * regionLength };\n    const topRight = { x: (regionCoord.x + 1) * regionLength - 1, y: regionCoord.y * regionLength };\n    const bottomLeft = { x: regionCoord.x * regionLength, y: (regionCoord.y + 1) * regionLength - 1 };\n    const bottomRight = { x: (regionCoord.x + 1) * regionLength - 1, y: (regionCoord.y + 1) * regionLength - 1 };\n    tileCoords.push(topLeft, topRight, bottomLeft, bottomRight);\n  });\n\n  return tileCoords;\n}\n\nexport function isTileInArea(tileCoord: WorldCoord, area: Area) {\n  return (\n    tileCoord.x >= area.x &&\n    tileCoord.x < area.x + area.width &&\n    tileCoord.y >= area.x &&\n    tileCoord.y < area.y + area.height\n  );\n}\n\nexport function coordEq(a?: Coord, b?: Coord) {\n  if (!a && !b) return true;\n  if (!a || !b) return false;\n  return a.x === b.x && a.y === b.y;\n}\n\nexport function addCoords(a: Coord, b: Coord) {\n  return {\n    x: a.x + b.x,\n    y: a.y + b.y,\n  };\n}\n\nexport function pixelToChunkCoord(pixelCoord: PixelCoord, chunkSize: number): ChunkCoord {\n  return { x: Math.floor(pixelCoord.x / chunkSize), y: Math.floor(pixelCoord.y / chunkSize) };\n}\n\nexport function chunkToPixelCoord(chunkCoord: ChunkCoord, chunkSize: number): PixelCoord {\n  return { x: chunkCoord.x * chunkSize, y: chunkCoord.y * chunkSize };\n}\n\nexport function pixelCoordToTileCoord(pixelCoord: PixelCoord, tileWidth: number, tileHeight: number): WorldCoord {\n  return {\n    x: Math.floor(pixelCoord.x / tileWidth),\n    y: Math.floor(pixelCoord.y / tileHeight),\n  };\n}\n\nexport function tileCoordToPixelCoord(tileCoord: WorldCoord, tileWidth: number, tileHeight: number): PixelCoord {\n  return {\n    x: tileCoord.x * tileWidth,\n    y: tileCoord.y * tileHeight,\n  };\n}\n\nexport function tileCoordToChunkCoord(\n  tileCoord: WorldCoord,\n  tileWidth: number,\n  tileHeight: number,\n  chunkSize: number\n): ChunkCoord {\n  const pixelCoord = tileCoordToPixelCoord(tileCoord, tileWidth, tileHeight);\n  return pixelToChunkCoord(pixelCoord, chunkSize);\n}\n\nexport function chunkCoordToTileCoord(\n  chunkCoord: ChunkCoord,\n  tileWidth: number,\n  tileHeight: number,\n  chunkSize: number\n): WorldCoord {\n  const pixelCoord = chunkToPixelCoord(chunkCoord, chunkSize);\n  return pixelCoordToTileCoord(pixelCoord, tileWidth, tileHeight);\n}\n","import { deferred } from \"@latticexyz/utils\";\n\nexport async function load(scene: Phaser.Scene, callback: (loader: Phaser.Loader.LoaderPlugin) => void) {\n  const loader = scene.load;\n  callback(loader);\n  loader.start();\n  const [resolve, , promise] = deferred<void>();\n  loader.on(\"complete\", () => {\n    resolve();\n  });\n  return promise;\n}\n","import { CoordMap } from \"@latticexyz/utils\";\nimport { Area } from \"../types\";\nimport { pixelToChunkCoord } from \"./coords\";\n\nexport function getChunksInArea(area: Area, chunkSize: number) {\n  const topLeft = { x: area.x, y: area.y };\n  const bottomRight = { x: area.x + area.width, y: area.y + area.height };\n\n  const topLeftChunk = pixelToChunkCoord(topLeft, chunkSize);\n  const bottomRightChunk = pixelToChunkCoord(bottomRight, chunkSize);\n\n  const numChunksX = bottomRightChunk.x - topLeftChunk.x + 1;\n  const numChunksY = bottomRightChunk.y - topLeftChunk.y + 1;\n\n  const chunksInArea = new CoordMap<boolean>();\n\n  for (let x = 0; x < numChunksX; x++) {\n    for (let y = 0; y < numChunksY; y++) {\n      chunksInArea.set(\n        {\n          x: topLeftChunk.x + x,\n          y: topLeftChunk.y + y,\n        },\n        true\n      );\n    }\n  }\n\n  return chunksInArea;\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nexport function getObjectsInArea(groups: Phaser.GameObjects.Group[], area: Phaser.Geom.Rectangle) {\n  const ids = [];\n  for (const group of groups) {\n    for (const object of group.getChildren() as any[]) {\n      if (object.active && \"x\" in object && \"y\" in object && area.contains(object.x, object.y)) {\n        console.log(\"got one\", object);\n        ids.push(object);\n      }\n    }\n  }\n  return ids.filter((x) => x !== undefined);\n}\n","import { Animation, Assets } from \"../types\";\n\nexport function generateFrames<A extends Assets>(\n  anims: Phaser.Animations.AnimationManager,\n  animation: Animation<A>\n): Phaser.Types.Animations.AnimationFrame[] {\n  if (animation.prefix && animation.suffix) {\n    return anims.generateFrameNames(animation.assetKey, {\n      start: animation.startFrame,\n      end: animation.endFrame,\n      prefix: animation.prefix,\n      suffix: animation.suffix,\n    });\n  } else {\n    return anims.generateFrameNumbers(animation.assetKey, { start: animation.startFrame, end: animation.endFrame });\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nconst SpritePipeline = Phaser.Renderer.WebGL.Pipelines.SpriteFXPipeline || Object;\nexport class HueTintAndOutlineFXPipeline extends SpritePipeline {\n  public static readonly KEY = \"HueTintFXPipeline\";\n\n  private _tintColor = new Phaser.Display.Color();\n\n  private _outline = 0;\n  private _outlineColor = new Phaser.Display.Color();\n\n  constructor(game: Phaser.Game) {\n    super({\n      game: game,\n      renderTarget: true,\n      fragShader: `\n        precision mediump float;\n        uniform sampler2D uMainSampler;\n        uniform vec2 uTextureSize;\n        uniform vec3 tintColor;\n        uniform int outline;\n        uniform vec3 outlineColor;\n        varying vec2 outTexCoord;\n        \n        vec3 rgb2hsv(vec3 c)\n        {\n            vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n            vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n            vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n            float d = q.x - min(q.w, q.y);\n            float e = 1.0e-10;\n            return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n        }\n        \n        void main(void)\n        {\n            vec4 srcColor;\n            vec4 outColor;\n            vec3 hsvColor;\n            vec3 rgbColor;\n            srcColor = texture2D(uMainSampler, outTexCoord);\n            hsvColor = rgb2hsv(srcColor.rgb);\n            if (hsvColor.g == 0.0 && !(tintColor.r == 0.0 && tintColor.g == 0.0 && tintColor.b == 0.0))\n            {\n              rgbColor = srcColor.rgb * tintColor;\n            } else {\n              rgbColor = srcColor.rgb;\n            }\n            outColor = vec4(rgbColor.r, rgbColor.g, rgbColor.b, srcColor.a);\n            if(outline == 1) {\n              vec2 distance = vec2(2.0, 2.0) / uTextureSize;\n              float upAlpha = texture2D(uMainSampler, outTexCoord + vec2(0.0, distance.y)).a;\n              float leftAlpha = texture2D(uMainSampler, outTexCoord + vec2(-distance.x, 0.0)).a;\n              float downAlpha = texture2D(uMainSampler, outTexCoord + vec2(0.0, -distance.y)).a;\n              float rightAlpha = texture2D(uMainSampler, outTexCoord + vec2(distance.x, 0.0)).a;\n              if (srcColor.a == 0.0 && max(max(upAlpha, downAlpha), max(leftAlpha, rightAlpha)) == 1.0)\n              {\n                outColor = vec4(outlineColor, 1.0);\n              }\n            }\n            gl_FragColor = outColor; \n        }\n        `,\n    });\n  }\n\n  onDrawSprite(obj: Phaser.GameObjects.Sprite) {\n    const hueTint = (obj.pipelineData as any).hueTint;\n\n    const outline = (obj.pipelineData as any).outline;\n    const outlineColor = (obj.pipelineData as any).outlineColor;\n\n    let tintColor = hueTint ? hueTint : 0x000000;\n    if (typeof tintColor === \"number\") {\n      tintColor = Phaser.Display.Color.IntegerToRGB(tintColor);\n    }\n\n    if (outline) {\n      this._outline = 1;\n\n      let _outlineColor = outlineColor ?? 0x000000;\n      if (typeof _outlineColor === \"number\") {\n        _outlineColor = Phaser.Display.Color.IntegerToRGB(outlineColor);\n      }\n\n      this._outlineColor.setFromRGB(_outlineColor);\n    } else {\n      this._outline = 0;\n    }\n\n    this._tintColor.setFromRGB(tintColor);\n  }\n\n  onDraw(renderTarget: Phaser.Renderer.WebGL.RenderTarget) {\n    this.set2f(\"uTextureSize\", this.renderer.width, this.renderer.height);\n    this.set3f(\"tintColor\", this._tintColor.redGL, this._tintColor.greenGL, this._tintColor.blueGL);\n\n    this.set1i(\"outline\", this._outline);\n    this.set3f(\"outlineColor\", this._outlineColor.redGL, this._outlineColor.greenGL, this._outlineColor.blueGL);\n\n    this.drawToGame(renderTarget);\n  }\n}\n","export class MultiHueTintPipeline extends Phaser.Renderer.WebGL.Pipelines.MultiPipeline {\n  public static readonly KEY = \"MultiHueTintPipeline\";\n  constructor(game: Phaser.Game) {\n    super({\n      game: game,\n      fragShader: `\n        #define SHADER_NAME PHASER_MULTI_V2_FS\n        #define numTextures %count%\n        precision highp float;\n        uniform sampler2D uMainSampler[%count%];\n        varying vec2 outTexCoord;\n        varying float outTexId;\n        varying float outTintEffect;\n        varying vec4 outTint;\n        \n        vec4 getSampler (int index, vec2 uv)\n        {\n            for (int i = 0; i < numTextures; ++i)\n            {\n                if (i == index)\n                {\n                    return texture2D(uMainSampler[i], uv);\n                }\n            }\n        \n            //  Return black\n            return vec4(0);\n        }\n        vec3 rgb2hsv(vec3 c)\n        {\n            vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n            vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n            vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n            float d = q.x - min(q.w, q.y);\n            float e = 1.0e-10;\n            return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n        }\n        vec3 hsv2rgb(vec3 c)\n        {\n            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n        }\n        \n        void main ()\n        {\n            vec4 srcColor;\n            vec3 hsvColor;\n            vec3 rgbColor;\n            vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);\n            srcColor = getSampler(int(outTexId), outTexCoord);\n            vec4 color = srcColor * texel;\n            //  Multiply texture tint\n            vec3 hueTintColor = outTint.bgr;\n            if (hueTintColor != vec3(0.0, 0.0, 0.0)) {\n              hsvColor = rgb2hsv(srcColor.rgb);\n              if (hsvColor.g == 0.0 && srcColor.a == 1.)\n              {\n                vec3 color = hsv2rgb(hsvColor);\n                rgbColor = color * hueTintColor;\n              } else {\n                rgbColor = hsv2rgb(hsvColor);\n              }\n              color = vec4(rgbColor.r, rgbColor.g, rgbColor.b, srcColor.a);\n            }\n            gl_FragColor = color;\n        }\n        `,\n    });\n  }\n}\n","import { HueTintAndOutlineFXPipeline, MultiHueTintPipeline } from \"./pipelines\";\n\nexport function defineScene(options: {\n  key: string;\n  preload?: (scene: Phaser.Scene) => void;\n  create?: (scene: Phaser.Scene) => void;\n  update?: (scene: Phaser.Scene) => void;\n}) {\n  const { preload, create, update, key } = options;\n  return class GameScene extends Phaser.Scene {\n    constructor() {\n      super({ key });\n    }\n\n    preload() {\n      preload && preload(this);\n    }\n\n    create() {\n      create && create(this);\n      const renderer = this.renderer as Phaser.Renderer.WebGL.WebGLRenderer;\n      if (renderer?.pipelines) {\n        renderer.pipelines.add(HueTintAndOutlineFXPipeline.KEY, new HueTintAndOutlineFXPipeline(this.game));\n        renderer.pipelines.add(MultiHueTintPipeline.KEY, new MultiHueTintPipeline(this.game));\n      }\n    }\n\n    update() {\n      update && update(this);\n    }\n  };\n}\n","import { GameScene } from \"./types\";\n\nexport function definePhaserConfig(options: {\n  scenes: GameScene[];\n  scale: Phaser.Types.Core.GameConfig[\"scale\"];\n}): Phaser.Types.Core.GameConfig {\n  return {\n    type: Phaser.WEBGL,\n    scale: options.scale,\n    pixelArt: true,\n    autoFocus: true,\n    render: {\n      antialiasGL: false,\n      pixelArt: true,\n    },\n    scene: options.scenes,\n  };\n}\n","export enum AssetType {\n  Image,\n  SpriteSheet,\n  MultiAtlas,\n}\n\nexport const GameObjectClasses = {\n  Sprite: Phaser.GameObjects.Sprite,\n  Rectangle: Phaser.GameObjects.Rectangle,\n  Line: Phaser.GameObjects.Line,\n  Text: Phaser.GameObjects.Text,\n};\n","import { map, Observable, Subject } from \"rxjs\";\nimport { Area, ChunkCoord } from \"./types\";\nimport { getChunksInArea } from \"./utils\";\nimport { CoordMap, subtract } from \"@latticexyz/utils\";\n\nexport function createChunks(worldView$: Observable<Area>, chunkSize: number, padding = 100) {\n  const visibleChunks = { current: new CoordMap<boolean>() };\n\n  const addedChunks$ = new Subject<ChunkCoord>();\n  const removedChunks$ = new Subject<ChunkCoord>();\n\n  const visibleChunkStream = worldView$.pipe(\n    map(({ x, y, width, height }) =>\n      // Calculate current chunks from the world view\n      getChunksInArea(\n        {\n          x: x - padding,\n          y: y - padding,\n          width: width + 2 * padding,\n          height: height + 2 * padding,\n        },\n        chunkSize\n      )\n    )\n  );\n\n  visibleChunkStream.subscribe((newVisibleChunks) => {\n    const added = subtract(newVisibleChunks, visibleChunks.current); // Chunks that are visible not but not before\n    for (const coord of added.coords()) addedChunks$.next(coord);\n\n    const removed = subtract(visibleChunks.current, newVisibleChunks); // Chunks that were visible before but not now\n    for (const coord of removed.coords()) removedChunks$.next(coord);\n\n    visibleChunks.current = newVisibleChunks;\n  });\n\n  return {\n    addedChunks$: addedChunks$.asObservable(),\n    removedChunks$: removedChunks$.asObservable(),\n    chunkSize,\n    visibleChunks,\n  };\n}\n","import { Gesture } from \"@use-gesture/vanilla\";\nimport { BehaviorSubject, filter, map, sampleTime, scan, Subject, throttleTime } from \"rxjs\";\nimport { tileCoordToPixelCoord } from \"./utils\";\nimport { Camera, CameraConfig, Coord, GestureState, ObjectPool } from \"./types\";\n\nexport function createCamera(phaserCamera: Phaser.Cameras.Scene2D.Camera, options: CameraConfig): Camera {\n  // Stop default gesture events to not collide with use-gesture\n  // https://github.com/pmndrs/use-gesture/blob/404e2b2ac145a45aff179c1faf5097b97414731c/documentation/pages/docs/gestures.mdx#about-the-pinch-gesture\n  document.addEventListener(\"gesturestart\", (e) => e.preventDefault());\n  document.addEventListener(\"gesturechange\", (e) => e.preventDefault());\n\n  const worldView$ = new BehaviorSubject<Phaser.Cameras.Scene2D.Camera[\"worldView\"]>(phaserCamera.worldView);\n  const zoom$ = new BehaviorSubject<number>(phaserCamera.zoom);\n  const wheelStream$ = new Subject<GestureState<\"onWheel\">>();\n  const pinchStream$ = new Subject<GestureState<\"onPinch\">>();\n\n  const gesture = new Gesture(\n    phaserCamera.scene.game.canvas,\n    {\n      onPinch: (state) => pinchStream$.next(state),\n      onWheel: (state) => wheelStream$.next(state),\n    },\n    {}\n  );\n\n  // function getNearestLevel(currentZoom: number): number {\n  //   return Math.pow(2, Math.floor(Math.log(currentZoom * 2) / Math.log(2))) / 2;\n  // }\n\n  const onResize = () => {\n    requestAnimationFrame(() => worldView$.next(phaserCamera.worldView));\n  };\n  phaserCamera.scene.scale.addListener(\"resize\", onResize);\n\n  function setZoom(zoom: number) {\n    phaserCamera.setZoom(zoom);\n    worldView$.next(phaserCamera.worldView);\n    zoom$.next(zoom);\n  }\n\n  const pinchSub = pinchStream$\n    .pipe(\n      throttleTime(10),\n      map((state) => {\n        // Because this event stream is throttled, we're dropping events which contain delta data, so we need to calculate the delta ourselves.\n        const zoom = zoom$.getValue();\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        const delta = state.offset[0] - zoom;\n        const scaledDelta = delta * options.pinchSpeed;\n        return zoom + scaledDelta;\n      }), // Compute pinch speed\n      map((zoom) => Math.min(Math.max(zoom, options.minZoom), options.maxZoom)), // Limit zoom values\n      scan((acc, curr) => [acc[1], curr], [1, 1]) // keep track of the last value to offset the map position (not implemented yet)\n    )\n    .subscribe(([, zoom]) => {\n      // Set the gesture zoom state to the current zoom value to avoid zooming beyond the max values\n      if (gesture._ctrl.state.pinch) gesture._ctrl.state.pinch.offset[0] = zoom;\n      setZoom(zoom);\n    });\n\n  const wheelSub = wheelStream$\n    .pipe(\n      filter((state) => !state.pinching),\n      sampleTime(10),\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      map((state) => state.delta.map((x) => x * options.wheelSpeed)), // Compute wheel speed\n      map((movement) => movement.map((m: number) => m / phaserCamera.zoom)), // Adjust for current zoom value\n      map((movement) => [phaserCamera.scrollX + movement[0], phaserCamera.scrollY + movement[1]]) // Compute new pinch\n    )\n    .subscribe(([x, y]) => {\n      phaserCamera.setScroll(x, y);\n      worldView$.next(phaserCamera.worldView);\n    });\n\n  function ignore(objectPool: ObjectPool, ignore: boolean) {\n    objectPool.ignoreCamera(phaserCamera.id, ignore);\n  }\n\n  function centerOnCoord(tileCoord: Coord, tileWidth: number, tileHeight: number) {\n    const pixelCoord = tileCoordToPixelCoord(tileCoord, tileWidth, tileHeight);\n    centerOn(pixelCoord.x, pixelCoord.y);\n  }\n\n  function centerOn(x: number, y: number) {\n    phaserCamera.centerOn(x, y);\n    requestAnimationFrame(() => worldView$.next(phaserCamera.worldView));\n  }\n\n  function setScroll(x: number, y: number) {\n    phaserCamera.setScroll(x, y);\n    requestAnimationFrame(() => worldView$.next(phaserCamera.worldView));\n  }\n\n  return {\n    phaserCamera,\n    worldView$,\n    zoom$,\n    ignore,\n    dispose: () => {\n      pinchSub.unsubscribe();\n      wheelSub.unsubscribe();\n      gesture.destroy();\n      phaserCamera.scene.scale.removeListener(\"resize\", onResize);\n    },\n    centerOnCoord,\n    centerOn,\n    setScroll,\n    setZoom,\n  };\n}\n","import { computed, observe, reaction } from \"mobx\";\nimport { from, map, mergeMap, pipe } from \"rxjs\";\nimport { filterNullish } from \"@latticexyz/utils\";\nimport { Camera, ChunkCoord, Chunks, Coord, EmbodiedEntity, ObjectPool } from \"./types\";\nimport { pixelToChunkCoord, coordEq } from \"./utils\";\nimport { CoordMap } from \"@latticexyz/utils\";\n\nfunction createRegistry() {\n  const coordToIds = new CoordMap<Set<string>>();\n  const idToCoord = new Map<string, Coord>();\n\n  function get(coord: Coord): Set<string> {\n    let set = coordToIds.get(coord);\n    if (!set) {\n      set = new Set<string>();\n      coordToIds.set(coord, set);\n    }\n    return set;\n  }\n\n  function set(id: string, coord: Coord) {\n    // Remove from prev set\n    const prevCoord = idToCoord.get(id);\n    const idsAtPrevCoord = prevCoord && get(prevCoord);\n    idsAtPrevCoord?.delete(id);\n\n    // Add to new set\n    const idsAtNewCoord = get(coord);\n    idsAtNewCoord.add(id);\n\n    // Set new idToCoord mapping\n    idToCoord.set(id, coord);\n  }\n\n  function remove(id: string) {\n    const prevCoord = idToCoord.get(id);\n    const idsAtCoord = prevCoord && get(prevCoord);\n    idsAtCoord?.delete(id);\n    idToCoord.delete(id);\n  }\n\n  return { set, remove, get };\n}\n\nexport function createCulling(objectPool: ObjectPool, camera: Camera, chunks: Chunks) {\n  const chunkRegistry = createRegistry();\n  const disposer = new Map<string, () => void>();\n\n  const chunkToEntity = pipe(\n    map((chunk: ChunkCoord) => from(chunkRegistry.get(chunk))), // Map to streams of entityIds\n    mergeMap((entities) => entities), // Flatten the stream of entities\n    map((entityId) => objectPool.get(entityId, \"Existing\")), // Map entityId to embodiedEntity\n    filterNullish()\n  );\n\n  // Spawn entities when their chunk appears in the viewport\n  const addedChunkSub = chunks.addedChunks$.pipe(chunkToEntity).subscribe((entity) => entity.spawn());\n\n  // Despawn entites when their chunk disappears from the viewport\n  const removedChunkSub = chunks.removedChunks$.pipe(chunkToEntity).subscribe((entity) => entity.despawn());\n\n  // Keep track of entity's chunk\n  function trackEntity(entity: EmbodiedEntity<never>) {\n    if (disposer.get(entity.id)) console.error(\"Entity is being tracked multiple times\", entity);\n    const chunk = computed(() => pixelToChunkCoord(entity.position, chunks.chunkSize), { equals: coordEq });\n    const dispose = reaction(\n      () => chunk.get(),\n      (newChunk) => {\n        // Register the new chunk position\n        chunkRegistry.set(entity.id, newChunk);\n\n        // Check whether entity is in the viewport if it switched chunks\n        const visible = chunks.visibleChunks.current.get(newChunk);\n        if (visible) {\n          entity.spawn();\n        } else {\n          entity.despawn();\n        }\n      },\n      { fireImmediately: true }\n    );\n    disposer.set(entity.id, dispose);\n  }\n\n  // Setup tracking of entity chunks\n  const disposeObjectPoolObserver = observe(objectPool.objects, (change) => {\n    if (change.type === \"add\") {\n      trackEntity(change.newValue as EmbodiedEntity<never>);\n    }\n    if (change.type === \"delete\") {\n      chunkRegistry.remove(change.oldValue.id);\n      const dispose = disposer.get(change.oldValue.id);\n      if (dispose) dispose();\n      disposer.delete(change.oldValue.id);\n    }\n  });\n\n  return {\n    dispose: () => {\n      for (const d of disposer.values()) d();\n      disposeObjectPoolObserver();\n      addedChunkSub.unsubscribe();\n      removedChunkSub.unsubscribe();\n    },\n  };\n}\n","import { observable, runInAction } from \"mobx\";\nimport { isRectangle, isSprite } from \"./guards\";\nimport {\n  EmbodiedEntity,\n  GameObject,\n  GameObjectComponent,\n  GameObjectFunction,\n  GameObjectTypes,\n  PixelCoord,\n} from \"./types\";\nimport { removeAllTweens } from \"./utils\";\n\nexport function createEmbodiedEntity<Type extends keyof GameObjectTypes>(\n  id: string,\n  group: Phaser.GameObjects.Group,\n  type: Type,\n  currentCameraFilter = 0\n): EmbodiedEntity<Type> {\n  const position: PixelCoord = observable({ x: 0, y: 0 });\n  const onOnce = new Map<string, GameObjectFunction<Type>>();\n  const onUpdate = new Map<string, GameObjectFunction<Type>>();\n  let activeGameObject: GameObject<Type> | undefined;\n  const cameraFilter = { current: currentCameraFilter };\n\n  /**\n   * Syncronizes updates to game object positions to the EmbodiedEntity's position\n   */\n  function trackPositionUpdates(func: GameObjectFunction<Type>): GameObjectFunction<Type> {\n    if (!modifiesPosition(func)) return func;\n\n    return (gameObject) => {\n      func(gameObject);\n      runInAction(() => {\n        position.x = gameObject.x;\n        position.y = gameObject.y;\n      });\n    };\n  }\n\n  /**\n   * Stores and executes the component.\n   * Once and Update functions are stored.\n   * Now and Once functions are executed if there is an active game object.\n   * Now is executed first and awaited, before Once is executed.\n   * @param component: GameObjectComponent definition, including id, and optional functions for now, once and update\n   */\n  async function setComponent({ id, now, once, update }: GameObjectComponent<Type>) {\n    // Handle position update when setting the component\n    const newPosition = once && modifiesPosition(once);\n    if (newPosition) {\n      runInAction(() => {\n        position.x = newPosition.x ?? position.x;\n        position.y = newPosition.y ?? position.y;\n      });\n    }\n\n    // Store functions\n    once && onOnce.set(id, trackPositionUpdates(once));\n    update && onUpdate.set(id, trackPositionUpdates(update));\n\n    // Execute functions\n    if (activeGameObject && now) await trackPositionUpdates(now)(activeGameObject);\n    if (activeGameObject && once) once(activeGameObject);\n  }\n\n  function hasComponent(id: string): boolean {\n    return onOnce.has(id) || onUpdate.has(id);\n  }\n\n  function removeComponent(id: string, stop?: boolean) {\n    onOnce.delete(id);\n    onUpdate.delete(id);\n\n    // Reset the entity and reapply all onOnce components\n    if (activeGameObject) {\n      reset(activeGameObject, stop);\n      executeGameObjectFunctions(activeGameObject, onOnce.values());\n    }\n  }\n\n  function reset(gameObject: GameObject<Type>, stop = true) {\n    if (stop) {\n      if (isSprite(gameObject, type)) gameObject.stop();\n      removeAllTweens(gameObject);\n    }\n    gameObject.setDepth(10);\n    gameObject.cameraFilter = cameraFilter.current;\n    gameObject.resetPipeline(true, true);\n    gameObject.setScale(1, 1);\n    gameObject.setOrigin(0, 0);\n    gameObject.setAlpha(1);\n    gameObject.setScrollFactor(1);\n    gameObject.clearMask();\n    gameObject.setData(\"objectPoolId\", null);\n    if (isSprite(gameObject, type)) {\n      gameObject.clearTint();\n      gameObject.setTexture(\"\");\n    }\n    if (isRectangle(gameObject, type)) {\n      gameObject.width = 0;\n      gameObject.height = 0;\n    }\n  }\n\n  function setCameraFilter(filter: number) {\n    cameraFilter.current = filter;\n    if (activeGameObject) activeGameObject.cameraFilter = filter;\n  }\n\n  function spawn() {\n    if (activeGameObject) return;\n    const gameObject: GameObject<Type> = group.get();\n    reset(gameObject);\n\n    // Run all functions that are supposed to run once\n    executeGameObjectFunctions(gameObject, onOnce.values());\n\n    // Bind all functions that are supposed to run on update\n    // gameObject.onUpdate = () => executeGameObjectFunctions(gameObject, onUpdate.values());\n\n    gameObject.setActive(true);\n    gameObject.setVisible(true);\n    gameObject.setData(\"objectPoolId\", id);\n    activeGameObject = gameObject;\n  }\n\n  function despawn() {\n    if (activeGameObject) {\n      group.killAndHide(activeGameObject);\n    }\n    activeGameObject = undefined;\n  }\n\n  return { setComponent, hasComponent, removeComponent, spawn, despawn, position, id, setCameraFilter, type };\n}\n\nfunction executeGameObjectFunctions<Type extends keyof GameObjectTypes>(\n  gameObject: GameObject<Type>,\n  functions: Iterable<GameObjectFunction<Type>>\n) {\n  if (!gameObject) return;\n  for (const func of functions) {\n    func(gameObject);\n  }\n}\n\nfunction modifiesPosition<Type extends keyof GameObjectTypes>(\n  func: GameObjectFunction<Type>\n): Partial<PixelCoord> | undefined {\n  let newPosition: Partial<PixelCoord> | undefined = undefined;\n  const gameObjectProxy = new Proxy(\n    { x: undefined, y: undefined },\n    {\n      get: (_, prop) => {\n        if (prop === \"setPosition\") return (x: number, y: number) => (newPosition = { x, y });\n        if (prop === \"setX\") return (x: number) => (newPosition = { x });\n        if (prop === \"setY\") return (y: number) => (newPosition = { y });\n        return () => void 0;\n      },\n      set: (_, prop, value) => {\n        if (prop === \"x\") newPosition = newPosition ? { ...newPosition, x: value } : { x: value };\n        if (prop === \"y\") newPosition = newPosition ? { ...newPosition, y: value } : { y: value };\n        return true;\n      },\n    }\n  );\n  func(gameObjectProxy as GameObject<Type>);\n  return newPosition;\n}\n","import {\n  Assets,\n  CameraConfig,\n  LayerConfig,\n  MapConfig,\n  MapsConfig,\n  SceneConfig,\n  TilesetConfig,\n  Animation,\n  GameObjectTypes,\n  GameObject,\n  Sprite,\n} from \"./types\";\n\n// Add type safety to config definitions\n\nexport function defineAssetsConfig<A extends Assets>(assets: A) {\n  return assets;\n}\n\nexport function defineMapConfig<A extends Assets, T extends TilesetConfig<A>, L extends LayerConfig<A, T>>(\n  config: MapConfig<A, T, L>\n) {\n  return config;\n}\n\nexport function defineSceneConfig<\n  A extends Assets,\n  S extends { [key: string]: Sprite<Assets> },\n  T extends TilesetConfig<A>,\n  M extends MapsConfig<A, T>,\n  Ans extends Animation<A>[]\n>(config: SceneConfig<A, S, T, M, Ans>) {\n  return config;\n}\n\nexport function defineScaleConfig(config: Phaser.Types.Core.ScaleConfig) {\n  return config;\n}\n\nexport function defineCameraConfig(config: CameraConfig) {\n  return config;\n}\n\nexport function isSprite(\n  gameObject: Phaser.GameObjects.GameObject,\n  type: keyof GameObjectTypes\n): gameObject is GameObject<\"Sprite\"> {\n  return type === \"Sprite\";\n}\n\nexport function isRectangle(\n  gameObject: Phaser.GameObjects.GameObject,\n  type: keyof GameObjectTypes\n): gameObject is GameObject<\"Rectangle\"> {\n  return type === \"Rectangle\";\n}\n","import { EmbodiedEntity, GameObjectTypes } from \"./types\";\nimport { createEmbodiedEntity } from \"./createEmbodiedEntity\";\nimport { observable } from \"mobx\";\nimport { mapObject } from \"@latticexyz/utils\";\nimport { GameObjectClasses } from \"./constants\";\n\ntype ObjectPoolReturnType<Type> = Type extends keyof GameObjectTypes\n  ? EmbodiedEntity<Type>\n  : EmbodiedEntity<keyof GameObjectTypes> | undefined;\n\nfunction isGameObjectType(t: string): t is keyof GameObjectTypes {\n  return Object.keys(GameObjectClasses).includes(t);\n}\n\nexport function createObjectPool(scene: Phaser.Scene) {\n  const groups = mapObject(GameObjectClasses, (classType) => scene.add.group({ classType })) as {\n    [key in keyof typeof GameObjectClasses]: Phaser.GameObjects.Group;\n  };\n\n  const objects = observable(new Map<string, EmbodiedEntity<keyof GameObjectTypes>>());\n  const cameraFilter = { current: 0 };\n\n  function get<Type extends keyof GameObjectTypes | \"Existing\">(\n    entity: number | string,\n    type: Type\n  ): ObjectPoolReturnType<typeof type> {\n    if (typeof entity === \"number\") entity = String(entity);\n    let embodiedEntity = objects.get(entity);\n    if (!isGameObjectType(type)) {\n      if (!embodiedEntity) return undefined as ObjectPoolReturnType<typeof type>;\n      return embodiedEntity as ObjectPoolReturnType<typeof type>;\n    }\n\n    // If the entity doesn't exist yet, we create a new one and track its chunk\n    if (!embodiedEntity) {\n      embodiedEntity = createEmbodiedEntity<typeof type>(entity, groups[type], type, cameraFilter.current);\n    }\n\n    if (!objects.has(entity)) {\n      objects.set(entity, embodiedEntity);\n    }\n\n    // Don't spawn here, let culling take care of spawning\n    // embodiedEntity.spawn();\n\n    return embodiedEntity as ObjectPoolReturnType<typeof type>;\n  }\n\n  function remove(entity: number | string) {\n    if (typeof entity === \"number\") entity = String(entity);\n    const object = objects.get(entity);\n    if (object) object.despawn();\n    objects.delete(entity);\n  }\n\n  function ignoreCamera(cameraId: number, ignore: boolean) {\n    if (ignore) {\n      cameraFilter.current |= cameraId;\n    } else {\n      cameraFilter.current &= ~cameraId;\n    }\n\n    for (const embodiedEntity of objects.values()) {\n      embodiedEntity.setCameraFilter(cameraFilter.current);\n    }\n  }\n\n  return { get, remove, objects, groups, ignoreCamera };\n}\n","import { ChunkedTilemap } from \"./types\";\nimport { ChunkCoord, Chunks, WorldCoord } from \"../types\";\nimport { mod, chunkToPixelCoord, tileCoordToChunkCoord, chunkCoordToTileCoord } from \"../utils\";\nimport { CoordMap } from \"@latticexyz/utils\";\nimport { MultiHueTintPipeline } from \"../pipelines\";\nimport { pickRandom } from \"@latticexyz/utils\";\n\nexport type ChunkedTilemapConfig<TileKeys extends number, LayerKeys extends string> = {\n  scene: Phaser.Scene;\n  tilesets: { [key: string]: Phaser.Tilemaps.Tileset };\n  layerConfig: {\n    layers: { [id in LayerKeys]: { tilesets: string[]; hasHueTintShader?: boolean } };\n    defaultLayer: LayerKeys;\n  };\n  chunks: Chunks;\n  backgroundTile: [number, ...number[]];\n  tiles: { [layer in LayerKeys]: CoordMap<TileKeys> };\n  tileWidth: number;\n  tileHeight: number;\n};\n\nexport function createChunkedTilemap<TileKeys extends number, LayerKeys extends string>(\n  params: ChunkedTilemapConfig<TileKeys, LayerKeys>\n): ChunkedTilemap<TileKeys, LayerKeys> {\n  const { scene, tilesets, layerConfig, chunks, backgroundTile, tiles, tileWidth, tileHeight } = params;\n  const relevantTilesets = Object.keys(layerConfig.layers)\n    .map((key) => layerConfig.layers[key as LayerKeys].tilesets)\n    .flat();\n\n  // Chunk pixel size must be a multiple of tile witdth and height.\n  if (mod(chunks.chunkSize, tileWidth) !== 0 || mod(chunks.chunkSize, tileHeight) !== 0) {\n    throw new Error(\"Chunks pixel size must be a multiple of tile width and height to be used with chunked tilemap\");\n  }\n\n  /*****************************************************\n   Setup \n   *****************************************************/\n\n  const maps = new CoordMap<Phaser.Tilemaps.Tilemap>();\n  const chunkTileSize = { x: chunks.chunkSize / tileWidth, y: chunks.chunkSize / tileHeight };\n  const disposer = new Set<() => void>();\n  const visible = { current: true };\n\n  // Render all current chunks\n  for (const chunk of chunks.visibleChunks.current.coords()) {\n    renderChunk(chunk);\n  }\n  // Render maps when they're in the viewport\n  const addedChunkSub = chunks.addedChunks$.subscribe((chunk) => {\n    renderChunk(chunk);\n  });\n\n  // Remove maps that are not in the viewport\n  const removedChunkSub = chunks.removedChunks$.subscribe((chunk) => {\n    destroyChunk(chunk);\n  });\n\n  disposer.add(() => addedChunkSub?.unsubscribe());\n  disposer.add(() => removedChunkSub?.unsubscribe);\n\n  /*****************************************************\n   Functions \n   *****************************************************/\n\n  function createLayers(\n    map: Phaser.Tilemaps.Tilemap,\n    scene: Phaser.Scene,\n    x: number,\n    y: number,\n    width: number,\n    height: number\n  ): {\n    layers: Phaser.Tilemaps.TilemapLayer[];\n    defaultLayer: Phaser.Tilemaps.TilemapLayer;\n  } {\n    const layers: { [key: string]: Phaser.Tilemaps.TilemapLayer } = {};\n\n    for (const key of Object.keys(layerConfig.layers)) {\n      const layer = layerConfig.layers[key as LayerKeys];\n      const tilemapLayer = map.createBlankLayer(\n        key,\n        layer.tilesets.map((id) => tilesets[id]),\n        x,\n        y,\n        width,\n        height\n      );\n      if (!tilemapLayer) {\n        console.error(`Adding tilemap layer ${key} failed.`);\n        continue;\n      }\n      layers[key] = tilemapLayer;\n      const renderer = scene.game.renderer as Phaser.Renderer.WebGL.WebGLRenderer;\n      if (layer.hasHueTintShader && renderer?.pipelines) {\n        layers[key].pipeline = renderer.pipelines.get(MultiHueTintPipeline.KEY);\n      }\n    }\n\n    return { layers: Object.values(layers), defaultLayer: layers[layerConfig.defaultLayer] };\n  }\n\n  function createMap(chunkCoord: WorldCoord): Phaser.Tilemaps.Tilemap {\n    const data: Phaser.Tilemaps.MapData = new Phaser.Tilemaps.MapData({\n      tileHeight,\n      tileWidth,\n      width: chunkTileSize.x,\n      height: chunkTileSize.y,\n      tilesets: Object.entries(tilesets)\n        .filter(([key]) => relevantTilesets.includes(key))\n        .map(([, tileset]) => tileset),\n    });\n\n    const map = new Phaser.Tilemaps.Tilemap(scene, data);\n    const topLeft = chunkToPixelCoord(chunkCoord, chunks.chunkSize);\n    const { defaultLayer } = createLayers(map, scene, topLeft.x, topLeft.y, chunkTileSize.x, chunkTileSize.y);\n    map.setLayer(defaultLayer);\n    maps.set(chunkCoord, map);\n    return map;\n  }\n\n  function getMapAtChunkCoord(chunkCoord: WorldCoord): Phaser.Tilemaps.Tilemap {\n    return maps.get(chunkCoord) || createMap(chunkCoord);\n  }\n\n  function getMapAtTileCoord(tileCoord: WorldCoord): Phaser.Tilemaps.Tilemap {\n    const chunkCoord = tileCoordToChunkCoord(tileCoord, tileWidth, tileHeight, chunks.chunkSize);\n    return getMapAtChunkCoord(chunkCoord);\n  }\n\n  function destroyChunk(chunkCoord: WorldCoord, force?: boolean) {\n    if ((!visible.current && !force) || !maps.has(chunkCoord)) return;\n    const map = getMapAtChunkCoord(chunkCoord);\n    map.destroy();\n    maps.delete(chunkCoord);\n  }\n\n  function putTileAt(coord: WorldCoord, tile: number, layer?: string, tint?: number) {\n    if (!visible.current) return;\n    const map = getMapAtTileCoord(coord);\n    const putTile = map.putTileAt(tile, mod(coord.x, chunkTileSize.x), mod(coord.y, chunkTileSize.y), undefined, layer);\n    if (putTile == null) {\n      throw new Error(\"putTileAt failed\");\n    }\n\n    putTile.width = map.tileWidth;\n    putTile.height = map.tileHeight;\n\n    if (tint) {\n      putTile.tint = tint;\n    }\n  }\n\n  function renderChunk(chunkCoord: ChunkCoord) {\n    if (!visible.current) return;\n    const map = getMapAtChunkCoord(chunkCoord);\n    const topLeftCoord = chunkCoordToTileCoord(chunkCoord, tileWidth, tileHeight, chunks.chunkSize);\n\n    for (const layer of Object.keys(layerConfig.layers))\n      map.forEachTile(\n        (tile) => {\n          const coord = { x: topLeftCoord.x + tile.x, y: topLeftCoord.y + tile.y };\n          const defaultIndex = layer === layerConfig.defaultLayer ? pickRandom(backgroundTile) : -1;\n          const index = tiles[layer as LayerKeys].get(coord) || defaultIndex;\n          tile.index = index;\n        },\n        undefined,\n        undefined,\n        undefined,\n        undefined,\n        undefined,\n        undefined,\n        layer\n      );\n  }\n\n  function dispose() {\n    for (const map of maps.values()) {\n      map.destroy();\n    }\n    maps.clear();\n    for (const d of disposer) {\n      d();\n    }\n  }\n\n  function size() {\n    return maps.size;\n  }\n\n  function setVisible(v: boolean) {\n    if (v === visible.current) return;\n    visible.current = v;\n    for (const chunk of chunks.visibleChunks.current.coords()) {\n      visible.current ? renderChunk(chunk) : destroyChunk(chunk, true);\n    }\n  }\n\n  return { size, putTileAt, dispose, setVisible, visible, tileWidth, tileHeight };\n}\n","import { VirtualTilemap } from \"./types\";\nimport { WorldCoord } from \"../types\";\nimport { tileCoordToChunkCoord } from \"../utils\";\nimport { CoordMap } from \"@latticexyz/utils\";\nimport { ChunkedTilemapConfig, createChunkedTilemap } from \"./createChunkedTilemap\";\n\nexport function createVirtualTilemap<TileKeys extends number, LayerKeys extends string>(\n  config: Omit<ChunkedTilemapConfig<TileKeys, LayerKeys>, \"tiles\">\n): VirtualTilemap<TileKeys, LayerKeys> {\n  const {\n    chunks,\n    layerConfig: { layers, defaultLayer },\n    tileWidth,\n    tileHeight,\n  } = config;\n\n  const tiles: { [key in LayerKeys]: CoordMap<TileKeys> } = {} as never;\n\n  for (const layerKey of Object.keys(layers)) {\n    tiles[layerKey as LayerKeys] = new CoordMap<TileKeys>();\n  }\n\n  const chunkedTilemap = createChunkedTilemap({ ...config, tiles });\n\n  function putTileAt(coord: WorldCoord, tile: TileKeys, layer?: LayerKeys, tint?: number) {\n    // Update virtual tilemap\n    tiles[layer || defaultLayer].set(coord, tile);\n\n    // Immediately update the physical tile if the chunk is in view\n    const chunk = tileCoordToChunkCoord(coord, tileWidth, tileHeight, chunks.chunkSize);\n    if (chunkedTilemap.visible && chunks.visibleChunks.current.get(chunk)) {\n      chunkedTilemap.putTileAt(coord, tile, layer, tint);\n    }\n  }\n\n  return { ...chunkedTilemap, putTileAt, tiles };\n}\n","import { AnimatedTilemap } from \".\";\nimport { WorldCoord } from \"../types\";\nimport { mod } from \"../utils\";\nimport { CoordMap } from \"@latticexyz/utils\";\nimport { ChunkedTilemapConfig } from \"./createChunkedTilemap\";\nimport { createVirtualTilemap } from \"./createVirtualTilemap\";\nimport { TileAnimation } from \"./types\";\n\nexport function createAnimatedTilemap<TileKeys extends number, LayerKeys extends string, AnimationKeys extends string>(\n  config: Omit<ChunkedTilemapConfig<TileKeys, string>, \"tiles\"> & { animationInterval: number }\n): AnimatedTilemap<TileKeys, LayerKeys, AnimationKeys> {\n  const {\n    layerConfig: { layers, defaultLayer },\n    animationInterval,\n    scene,\n  } = config;\n\n  const defaultLayerKey = defaultLayer as LayerKeys;\n  let lastStep = 0;\n  const animations: { [key in AnimationKeys]?: { frames: TileAnimation<TileKeys>; index: number } } = {};\n\n  const animatedTiles: { [key in LayerKeys]: CoordMap<AnimationKeys> } = {} as never;\n  for (const layerKey of Object.keys(layers)) {\n    animatedTiles[layerKey as LayerKeys] = new CoordMap<AnimationKeys>();\n  }\n\n  const pausedAnimations: { [key in LayerKeys]: CoordMap<AnimationKeys> } = {} as never;\n  for (const layerKey of Object.keys(layers)) {\n    pausedAnimations[layerKey as LayerKeys] = new CoordMap<AnimationKeys>();\n  }\n\n  const virtualTilemap = createVirtualTilemap(config);\n\n  function registerAnimation(animationKey: AnimationKeys, frames: TileAnimation<TileKeys>) {\n    animations[animationKey] = { frames, index: 0 };\n  }\n\n  function putAnimationAt(coord: WorldCoord, animationKey: AnimationKeys, layer: LayerKeys = defaultLayerKey) {\n    animatedTiles[layer].set(coord, animationKey);\n  }\n\n  function removeAnimationAt(coord: WorldCoord, layer: LayerKeys = defaultLayerKey) {\n    const animationKey = animatedTiles[layer].get(coord);\n    const animation = animationKey && animations[animationKey];\n    animatedTiles[layer].delete(coord);\n    if (animation) virtualTilemap.putTileAt(coord, animation.frames[0], layer);\n  }\n\n  function pauseAnimationAt(coord: WorldCoord, layer: LayerKeys = defaultLayerKey) {\n    const animationKey = animatedTiles[layer].get(coord);\n    if (!animationKey) return;\n    pausedAnimations[layer].set(coord, animationKey);\n    removeAnimationAt(coord, layer);\n  }\n\n  function resumeAnimationAt(coord: WorldCoord, layer: LayerKeys = defaultLayerKey) {\n    const animationKey = pausedAnimations[layer].get(coord);\n    if (!animationKey) return;\n    pausedAnimations[layer].delete(coord);\n    putAnimationAt(coord, animationKey, layer);\n  }\n\n  function animationStep() {\n    // Increase animation index for every animation\n    for (const animationKey of Object.keys(animations) as AnimationKeys[]) {\n      const animation = animations[animationKey];\n      if (animation) animation.index = mod(animation.index + 1, animation.frames.length);\n    }\n\n    // Update every animated tile\n    for (const layerKey of Object.keys(animatedTiles) as LayerKeys[]) {\n      const layer = animatedTiles[layerKey];\n      for (const coord of layer.coords()) {\n        const animationKey = layer.get(coord);\n        const animation = animationKey && animations[animationKey];\n        if (!animation) continue;\n        const currentFrame = animation.frames[animation.index];\n        virtualTilemap.putTileAt(coord, currentFrame, layerKey);\n      }\n    }\n  }\n\n  function update(time: number) {\n    if (time < lastStep + animationInterval) return;\n    lastStep = time;\n    animationStep();\n  }\n\n  function dispose() {\n    scene.events.removeListener(\"update\", update);\n    virtualTilemap.dispose();\n  }\n\n  scene.events.addListener(\"update\", update);\n\n  return {\n    ...virtualTilemap,\n    putAnimationAt,\n    removeAnimationAt,\n    pauseAnimationAt,\n    resumeAnimationAt,\n    registerAnimation,\n    dispose,\n  } as unknown as AnimatedTilemap<TileKeys, LayerKeys, AnimationKeys>;\n}\n","import {\n  bufferCount,\n  distinctUntilChanged,\n  filter,\n  fromEvent,\n  map,\n  merge,\n  Observable,\n  pairwise,\n  scan,\n  Subject,\n  throttleTime,\n} from \"rxjs\";\nimport { observable, reaction, runInAction } from \"mobx\";\nimport { Area } from \"./types\";\nimport { filterNullish } from \"@latticexyz/utils\";\n\nexport type Key = keyof typeof Phaser.Input.Keyboard.KeyCodes | \"POINTER_LEFT\" | \"POINTER_RIGHT\";\n\nexport function createInput(inputPlugin: Phaser.Input.InputPlugin) {\n  const disposers = new Set<() => void>();\n  const enabled = { current: true };\n\n  inputPlugin.mouse?.disableContextMenu();\n\n  function disableInput() {\n    enabled.current = false;\n  }\n\n  function enableInput() {\n    enabled.current = true;\n  }\n\n  function setCursor(cursor: string) {\n    inputPlugin.setDefaultCursor(cursor);\n  }\n\n  const keyboard$ = new Subject<Phaser.Input.Keyboard.Key>();\n\n  const pointermove$ = fromEvent(document, \"mousemove\").pipe(\n    filter(() => enabled.current),\n    map(() => {\n      return { pointer: inputPlugin.manager?.activePointer };\n    }),\n    filterNullish()\n  );\n\n  const pointerdown$: Observable<{ pointer: Phaser.Input.Pointer; event: MouseEvent }> = fromEvent(\n    document,\n    \"mousedown\"\n  ).pipe(\n    filter(() => enabled.current),\n    map((event) => ({ pointer: inputPlugin.manager?.activePointer, event: event as MouseEvent })),\n    filterNullish()\n  );\n\n  const pointerup$: Observable<{ pointer: Phaser.Input.Pointer; event: MouseEvent }> = fromEvent(\n    document,\n    \"mouseup\"\n  ).pipe(\n    filter(() => enabled.current),\n    map((event) => ({ pointer: inputPlugin.manager?.activePointer, event: event as MouseEvent })),\n    filterNullish()\n  );\n\n  // Click stream\n  const click$ = merge(pointerdown$, pointerup$).pipe(\n    filter(() => enabled.current),\n    map<{ pointer: Phaser.Input.Pointer; event: MouseEvent }, [boolean, number]>(({ event }) => [\n      event.type === \"mousedown\" && event.button === 0,\n      Date.now(),\n    ]), // Map events to whether the left button is down and the current timestamp\n    bufferCount(2, 1), // Store the last two timestamps\n    filter(([prev, now]) => prev[0] && !now[0] && now[1] - prev[1] < 250), // Only care if button was pressed before and is not anymore and it happened within 500ms\n    map(() => inputPlugin.manager?.activePointer), // Return the current pointer\n    filterNullish()\n  );\n\n  // Double click stream\n  const doubleClick$ = pointerdown$.pipe(\n    filter(() => enabled.current),\n    map(() => Date.now()), // Get current timestamp\n    bufferCount(2, 1), // Store the last two timestamps\n    filter(([prev, now]) => now - prev < 500), // Filter clicks with more than 500ms distance\n    throttleTime(500), // A third click within 500ms is not counted as another double click\n    map(() => inputPlugin.manager?.activePointer), // Return the current pointer\n    filterNullish()\n  );\n\n  // Right click stream\n  const rightClick$ = merge(pointerdown$, pointerup$).pipe(\n    filter(({ pointer }) => enabled.current && pointer.rightButtonDown()),\n    map(() => inputPlugin.manager?.activePointer), // Return the current pointer\n    filterNullish()\n  );\n\n  // Drag stream\n  const drag$ = merge(\n    pointerdown$.pipe(map(() => undefined)), // Reset the drag on left click\n    merge(pointerup$, pointermove$).pipe(\n      pairwise(), // Take the last two move or pointerup events\n      scan<[{ pointer: Phaser.Input.Pointer }, { pointer: Phaser.Input.Pointer }], Area | undefined>(\n        (acc, [{ pointer: prev }, { pointer: curr }]) =>\n          curr.leftButtonDown() // If the left butten is pressed...\n            ? prev.leftButtonDown() && acc // If the previous event wasn't mouseup and if the drag already started...\n              ? { ...acc, width: curr.worldX - acc.x, height: curr.worldY - acc.y } // Update the width/height\n              : { x: curr.worldX, y: curr.worldY, width: 0, height: 0 } // Else start the drag\n            : undefined,\n        undefined\n      ),\n      filterNullish(),\n      filter((area) => Math.abs(area.width) > 10 && Math.abs(area.height) > 10) // Prevent clicking to be mistaken as a drag\n    )\n  ).pipe(\n    filter(() => enabled.current),\n    distinctUntilChanged() // Prevent same value to be emitted in a row\n  );\n\n  const pressedKeys = observable(new Set<Key>());\n  const phaserKeyboard = inputPlugin.keyboard;\n  const codeToKey = new Map<number, Key>();\n\n  // Listen to all keys\n  for (const key of Object.keys(Phaser.Input.Keyboard.KeyCodes)) addKey(key);\n\n  // Subscriptions\n  const keySub = keyboard$.pipe(filter(() => enabled.current)).subscribe((key) => {\n    const keyName = codeToKey.get(key.keyCode);\n    if (!keyName) return;\n    runInAction(() => {\n      if (key.isDown) pressedKeys.add(keyName);\n      if (key.isUp) pressedKeys.delete(keyName);\n    });\n  });\n  disposers.add(() => keySub?.unsubscribe());\n\n  const pointerSub = merge(pointerdown$, pointerup$).subscribe(({ pointer }) => {\n    runInAction(() => {\n      if (pointer.leftButtonDown()) pressedKeys.add(\"POINTER_LEFT\");\n      else pressedKeys.delete(\"POINTER_LEFT\");\n\n      if (pointer.rightButtonDown()) pressedKeys.add(\"POINTER_RIGHT\");\n      else pressedKeys.delete(\"POINTER_RIGHT\");\n    });\n    //\n  });\n  disposers.add(() => pointerSub?.unsubscribe());\n\n  // Adds a key to include in the state\n  function addKey(key: string) {\n    if (!phaserKeyboard) {\n      console.warn(`Adding key ${key} failed. No phaser keyboard detected.`);\n      return;\n    }\n\n    // Add the key to the phaser keyboard input plugin\n    const keyObj = phaserKeyboard.addKey(key, false);\n    // Store the cleartext key map\n    codeToKey.set(keyObj.keyCode, key as Key);\n\n    keyObj.removeAllListeners();\n    keyObj.emitOnRepeat = true;\n    keyObj.on(\"down\", (keyEvent: Phaser.Input.Keyboard.Key) => keyboard$.next(keyEvent));\n    keyObj.on(\"up\", (keyEvent: Phaser.Input.Keyboard.Key) => keyboard$.next(keyEvent));\n  }\n\n  function onKeyPress(keySelector: (pressedKeys: Set<Key>) => boolean, callback: () => void) {\n    const disposer = reaction(\n      () => keySelector(pressedKeys),\n      (passes) => {\n        if (passes) callback();\n      },\n      { fireImmediately: true }\n    );\n    disposers.add(disposer);\n  }\n\n  function dispose() {\n    for (const disposer of disposers) {\n      disposer();\n    }\n  }\n\n  return {\n    keyboard$: keyboard$.asObservable(),\n    pointermove$,\n    pointerdown$,\n    pointerup$,\n    click$,\n    doubleClick$,\n    rightClick$,\n    drag$,\n    pressedKeys,\n    dispose,\n    disableInput,\n    enableInput,\n    setCursor,\n    enabled,\n    onKeyPress,\n  };\n}\n","import { defineScene } from \"./defineScene\";\nimport { definePhaserConfig } from \"./definePhaserConfig\";\nimport { load } from \"./utils\";\nimport { AssetType } from \"./constants\";\nimport { Scenes, Maps, ScenesConfig, Tilesets, PhaserEngineConfig } from \"./types\";\nimport { createChunks } from \"./createChunks\";\nimport { createCamera } from \"./createCamera\";\nimport { createCulling } from \"./createCulling\";\nimport { createObjectPool } from \"./createObjectPool\";\nimport { createAnimatedTilemap } from \"./tilemap\";\nimport { generateFrames } from \"./utils\";\nimport { createInput } from \"./createInput\";\nimport { deferred } from \"@latticexyz/utils\";\n\nexport async function createPhaserEngine<S extends ScenesConfig>(options: PhaserEngineConfig<S>) {\n  const { scale, sceneConfig, cameraConfig, cullingChunkSize } = options;\n\n  // Set up Phaser scenes\n  const sceneConstructors = Object.keys(sceneConfig).map((key) => {\n    const { preload, create, update } = sceneConfig[key];\n    return defineScene({ key, preload, create, update });\n  });\n\n  const phaserConfig = definePhaserConfig({ scenes: sceneConstructors, scale });\n  const game = new Phaser.Game(phaserConfig);\n\n  // Wait for phaser to boot\n  const [resolve, , promise] = deferred();\n\n  game.events.on(\"ready\", resolve);\n\n  // skip texture loading in headless mode for unit testing\n  if (phaserConfig.type === Phaser.HEADLESS) {\n    game.textures.emit(\"ready\");\n  }\n\n  await promise;\n\n  // Bind the game's size to the window size\n  function resize() {\n    const width = window.innerWidth / game.scale.zoom;\n    const height = window.innerHeight / game.scale.zoom;\n    game.scale.resize(width, height);\n  }\n  resize();\n  window.addEventListener(\"resize\", resize);\n\n  // Create scenes object\n  const partialScenes: Partial<Scenes<S>> = {};\n\n  for (const phaserScene of game.scene.getScenes(false)) {\n    const key = phaserScene.scene.key as keyof S;\n    const config = sceneConfig[key];\n\n    // Load assets\n    for (const [assetKey, asset] of Object.entries(sceneConfig[key].assets)) {\n      await load(phaserScene, (loader) => {\n        if (asset.type === AssetType.Image) {\n          loader.image(assetKey, asset.path);\n        } else if (asset.type === AssetType.SpriteSheet) {\n          loader.spritesheet(assetKey, asset.path, asset.options);\n        } else if (asset.type === AssetType.MultiAtlas) {\n          loader.multiatlas(assetKey, asset.path, asset.options.imagePath);\n        }\n      });\n    }\n\n    // Setup object pool\n    const objectPool = createObjectPool(phaserScene);\n\n    // Setup camera\n    const camera = createCamera(phaserScene.cameras.main, cameraConfig);\n\n    // Setup chunks for viewport culling\n    const cullingChunks = createChunks(camera.worldView$, cullingChunkSize);\n\n    // Setup viewport culling\n    const culling = createCulling(objectPool, camera, cullingChunks);\n\n    // Setup sprite animations\n    for (const anim of config.animations) {\n      phaserScene.anims.create({\n        key: anim.key,\n        frames: generateFrames(phaserScene.anims, anim),\n        frameRate: anim.frameRate,\n        repeat: anim.repeat,\n      });\n    }\n\n    // Setup tilesets\n    const emptyMap = new Phaser.Tilemaps.Tilemap(phaserScene, new Phaser.Tilemaps.MapData());\n    const partialTilesets: Tilesets<string> = {};\n    for (const [tilesetKey, { assetKey, tileWidth, tileHeight }] of Object.entries(sceneConfig[key][\"tilesets\"])) {\n      const tileset = emptyMap.addTilesetImage(tilesetKey, assetKey, tileWidth, tileHeight);\n      if (!tileset) {\n        console.error(`Adding tileset ${tilesetKey} failed.`);\n        continue;\n      }\n      partialTilesets[tilesetKey] = tileset;\n    }\n    const tilesets = partialTilesets as Tilesets<keyof S[typeof key][\"tilesets\"]>;\n\n    // Setup maps\n    const partialMaps: Partial<Maps<keyof S[typeof key][\"maps\"]>> = {};\n    for (const mapKey of Object.keys(config.maps)) {\n      const { layers, backgroundTile, tileWidth, tileHeight, animationInterval, tileAnimations, chunkSize } =\n        config.maps[mapKey];\n\n      // Setup chunks\n      const chunks = createChunks(camera.worldView$, chunkSize);\n\n      const map = createAnimatedTilemap({\n        scene: phaserScene,\n        tilesets,\n        layerConfig: layers,\n        chunks,\n        tileWidth,\n        tileHeight,\n        backgroundTile,\n        animationInterval,\n      });\n\n      // Register tilemap animations\n      if (tileAnimations) {\n        for (const [key, frames] of Object.entries(tileAnimations)) {\n          map.registerAnimation(key, frames);\n        }\n      }\n\n      partialMaps[mapKey as keyof (typeof sceneConfig)[typeof key][\"maps\"]] = map;\n    }\n    const maps = partialMaps as Maps<keyof S[typeof key][\"maps\"]>;\n\n    const input = createInput(phaserScene.input);\n\n    partialScenes[key] = { phaserScene, objectPool, camera, culling, maps, input, config: sceneConfig[key] };\n  }\n  const scenes = partialScenes as Scenes<S>;\n\n  return {\n    game,\n    scenes,\n    dispose: () => {\n      game.destroy(true);\n      for (const key of Object.keys(scenes)) {\n        const scene = scenes[key];\n        scene.camera.dispose();\n        scene.culling.dispose();\n        scene.input.dispose();\n        for (const map of Object.values(scene.maps)) {\n          map.dispose();\n        }\n      }\n\n      window.removeEventListener(\"resize\", resize);\n    },\n  };\n}\n","import { chunkToPixelCoord } from \"./utils\";\nimport { CoordMap } from \"@latticexyz/utils\";\nimport { Camera, Chunks, ObjectPool } from \"./types\";\nimport { AnimatedTilemap } from \"./tilemap\";\n\nfunction getRandomColor() {\n  const red = Math.random() * 0xff;\n  const green = Math.random() * 0xff;\n  const blue = Math.random() * 0xff;\n  return red * 0xffff + green * 0xff + blue;\n}\n\nexport function createDebugger(\n  camera: Camera,\n  chunks: Chunks,\n  scene: Phaser.Scene,\n  objectPool: ObjectPool,\n  map: AnimatedTilemap<number, string, string>\n) {\n  const options = {\n    logViewport: false,\n    visualizeChunks: true,\n    visualizeViewport: false,\n    logNumVisibleChunks: false,\n    logObjectStats: false,\n    logMaps: true,\n  };\n\n  const visualChunks = new CoordMap<Phaser.GameObjects.Rectangle>();\n  const worldViewRect = scene.add.rectangle(0, 0, 1, 1, 0xff0000, 0.2);\n  worldViewRect.setInteractive();\n  worldViewRect.on(\"pointerup\", () => {\n    console.log(\"clicked\", worldViewRect);\n  });\n\n  camera.worldView$.subscribe((worldView) => {\n    if (options.logViewport) {\n      console.log(worldView);\n    }\n\n    if (options.visualizeViewport) {\n      worldViewRect.setScale(worldView.width, worldView.height);\n      worldViewRect.setPosition(worldView.centerX, worldView.centerY);\n    }\n\n    if (options.logObjectStats) {\n      console.log(\n        `Entities: ${objectPool.objects.size} / Pool size: ${Object.values(objectPool.groups).reduce(\n          (acc, curr) => acc + curr.getChildren().length,\n          0\n        )} / Pool active: ${Object.values(objectPool.groups).reduce((acc, curr) => acc + curr.countActive(), 0)}`\n      );\n    }\n\n    if (options.logMaps) {\n      console.log(\"Num maps\", map.size());\n    }\n  });\n\n  chunks.addedChunks$.subscribe((chunk) => {\n    if (options.visualizeChunks) {\n      const pixelCoord = chunkToPixelCoord(chunk, chunks.chunkSize);\n      const visualChunk = scene.add.rectangle(\n        pixelCoord.x + chunks.chunkSize / 2,\n        pixelCoord.y + chunks.chunkSize / 2,\n        chunks.chunkSize,\n        chunks.chunkSize,\n        getRandomColor(),\n        0.5\n      );\n      visualChunk.setInteractive();\n      visualChunk.on(\"pointerup\", () => {\n        console.log(\"clicked\", visualChunk);\n      });\n      visualChunks.set(chunk, visualChunk);\n    }\n\n    if (options.logNumVisibleChunks) {\n      console.log(\"Number of visible chunks: \", visualChunks.size);\n    }\n  });\n\n  chunks.removedChunks$.subscribe((chunk) => {\n    if (options.visualizeChunks) {\n      visualChunks.get(chunk)?.destroy();\n      visualChunks.delete(chunk);\n    }\n\n    if (options.logNumVisibleChunks) {\n      console.log(\"Number of visible chunks: \", visualChunks.size);\n    }\n  });\n}\n"],"mappings":"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","names":["deferred","tween","config","options","resolve","promise","targets","removeAllTweens","gameObject","tweenManager","mod","a","b","ZERO_VECTOR","cornerTileCoordsFromRegionCoords","regionCoords","regionLength","tileCoords","regionCoord","topLeft","topRight","bottomLeft","bottomRight","isTileInArea","tileCoord","area","coordEq","a","b","addCoords","pixelToChunkCoord","pixelCoord","chunkSize","chunkToPixelCoord","chunkCoord","pixelCoordToTileCoord","tileWidth","tileHeight","tileCoordToPixelCoord","tileCoordToChunkCoord","chunkCoordToTileCoord","deferred","load","scene","callback","loader","resolve","promise","CoordMap","getChunksInArea","area","chunkSize","topLeft","bottomRight","topLeftChunk","pixelToChunkCoord","bottomRightChunk","numChunksX","numChunksY","chunksInArea","CoordMap","x","y","getObjectsInArea","groups","area","ids","group","object","x","generateFrames","anims","animation","SpritePipeline","HueTintAndOutlineFXPipeline","game","obj","hueTint","outline","outlineColor","tintColor","_outlineColor","renderTarget","__publicField","MultiHueTintPipeline","game","__publicField","defineScene","options","preload","create","update","key","renderer","HueTintAndOutlineFXPipeline","MultiHueTintPipeline","definePhaserConfig","options","AssetType","GameObjectClasses","map","Subject","CoordMap","subtract","createChunks","worldView$","chunkSize","padding","visibleChunks","addedChunks$","Subject","removedChunks$","map","x","y","width","height","getChunksInArea","newVisibleChunks","added","coord","removed","Gesture","BehaviorSubject","filter","map","sampleTime","scan","Subject","throttleTime","createCamera","phaserCamera","options","e","worldView$","BehaviorSubject","zoom$","wheelStream$","Subject","pinchStream$","gesture","Gesture","state","onResize","setZoom","zoom","pinchSub","throttleTime","map","scaledDelta","scan","acc","curr","wheelSub","filter","sampleTime","movement","m","x","y","ignore","objectPool","centerOnCoord","tileCoord","tileWidth","tileHeight","pixelCoord","tileCoordToPixelCoord","centerOn","setScroll","computed","observe","reaction","from","map","mergeMap","pipe","filterNullish","CoordMap","createRegistry","coordToIds","idToCoord","get","coord","set","id","prevCoord","remove","createCulling","objectPool","camera","chunks","chunkRegistry","disposer","chunkToEntity","pipe","map","chunk","from","mergeMap","entities","entityId","filterNullish","addedChunkSub","entity","removedChunkSub","trackEntity","computed","pixelToChunkCoord","coordEq","dispose","reaction","newChunk","disposeObjectPoolObserver","observe","change","d","observable","runInAction","defineAssetsConfig","assets","defineMapConfig","config","defineSceneConfig","defineScaleConfig","defineCameraConfig","isSprite","gameObject","type","isRectangle","createEmbodiedEntity","id","group","type","currentCameraFilter","position","observable","onOnce","onUpdate","activeGameObject","cameraFilter","trackPositionUpdates","func","modifiesPosition","gameObject","runInAction","setComponent","now","once","update","newPosition","hasComponent","removeComponent","stop","reset","executeGameObjectFunctions","isSprite","removeAllTweens","isRectangle","setCameraFilter","filter","spawn","despawn","functions","gameObjectProxy","_","prop","x","y","value","observable","mapObject","isGameObjectType","GameObjectClasses","createObjectPool","scene","groups","mapObject","classType","objects","observable","cameraFilter","get","entity","type","embodiedEntity","createEmbodiedEntity","remove","object","ignoreCamera","cameraId","ignore","CoordMap","pickRandom","createChunkedTilemap","params","scene","tilesets","layerConfig","chunks","backgroundTile","tiles","tileWidth","tileHeight","relevantTilesets","key","mod","maps","CoordMap","chunkTileSize","disposer","visible","chunk","renderChunk","addedChunkSub","removedChunkSub","destroyChunk","createLayers","map","x","y","width","height","layers","layer","tilemapLayer","id","renderer","MultiHueTintPipeline","createMap","chunkCoord","data","tileset","topLeft","chunkToPixelCoord","defaultLayer","getMapAtChunkCoord","getMapAtTileCoord","tileCoord","tileCoordToChunkCoord","force","putTileAt","coord","tile","tint","putTile","topLeftCoord","chunkCoordToTileCoord","defaultIndex","index","dispose","d","size","setVisible","v","CoordMap","createVirtualTilemap","config","chunks","layers","defaultLayer","tileWidth","tileHeight","tiles","layerKey","CoordMap","chunkedTilemap","createChunkedTilemap","putTileAt","coord","tile","layer","tint","chunk","tileCoordToChunkCoord","CoordMap","createAnimatedTilemap","config","layers","defaultLayer","animationInterval","scene","defaultLayerKey","lastStep","animations","animatedTiles","layerKey","CoordMap","pausedAnimations","virtualTilemap","createVirtualTilemap","registerAnimation","animationKey","frames","putAnimationAt","coord","layer","removeAnimationAt","animation","pauseAnimationAt","resumeAnimationAt","animationStep","mod","currentFrame","update","time","dispose","bufferCount","distinctUntilChanged","filter","fromEvent","map","merge","pairwise","scan","Subject","throttleTime","observable","reaction","runInAction","filterNullish","createInput","inputPlugin","disposers","enabled","disableInput","enableInput","setCursor","cursor","keyboard$","pointermove$","pointerdown$","event","pointerup$","click$","prev","now","doubleClick$","rightClick$","pointer","drag$","acc","curr","area","pressedKeys","phaserKeyboard","codeToKey","key","addKey","keySub","keyName","pointerSub","keyObj","keyEvent","onKeyPress","keySelector","callback","disposer","passes","dispose","deferred","createPhaserEngine","options","scale","sceneConfig","cameraConfig","cullingChunkSize","sceneConstructors","key","preload","create","update","defineScene","phaserConfig","definePhaserConfig","game","resolve","promise","resize","width","height","partialScenes","phaserScene","config","assetKey","asset","load","loader","objectPool","createObjectPool","camera","createCamera","cullingChunks","createChunks","culling","createCulling","anim","generateFrames","emptyMap","partialTilesets","tilesetKey","tileWidth","tileHeight","tileset","tilesets","partialMaps","mapKey","layers","backgroundTile","animationInterval","tileAnimations","chunkSize","chunks","map","createAnimatedTilemap","frames","maps","input","createInput","scenes","scene","CoordMap","getRandomColor","red","green","blue","createDebugger","camera","chunks","scene","objectPool","map","options","visualChunks","worldViewRect","worldView","acc","curr","chunk","pixelCoord","chunkToPixelCoord","visualChunk"]}