{"version":3,"sources":["../src/initCache.ts"],"sourcesContent":["import { arrayToIterator, deferred, mergeIterators, transformIterator } from \"@latticexyz/utils\";\n\nconst indexedDB = self.indexedDB;\nconst VERSION = 2;\n\n/**\n * Initialize an indexedDB store.\n *\n * @param db IDBDatabase\n * @param storeId Id of the store to initialize\n */\nfunction initStore(db: IDBDatabase, storeId: string) {\n  if (!db.objectStoreNames.contains(storeId)) {\n    db.createObjectStore(storeId);\n  }\n}\n\n/**\n * Initialize an indexedDB database.\n *\n * @param dbId Id of the database to initialize.\n * @param stores Keys of the stores to initialize.\n * @param version Optional: version of the database to initialize.\n * @param idb Optional: custom indexedDB factory\n * @returns Promise resolving with IDBDatabase object\n */\nfunction initDb(dbId: string, stores: string[], version = VERSION, idb: IDBFactory = indexedDB) {\n  const [resolve, reject, promise] = deferred<IDBDatabase>();\n\n  const request = idb.open(dbId, version);\n\n  // Create store and index\n  request.onupgradeneeded = () => {\n    const db = request.result;\n    for (const store of stores) {\n      initStore(db, store);\n    }\n  };\n\n  request.onsuccess = () => {\n    const db = request.result;\n    resolve(db);\n  };\n\n  request.onerror = (error) => {\n    reject(new Error(JSON.stringify(error)));\n  };\n\n  return promise;\n}\n\ntype Stores = { [key: string]: unknown };\ntype StoreKey<S extends Stores> = keyof S & string;\n\n/**\n * Initialize an abstracted Cache object to simplify interaction with the indexedDB database.\n *\n * @param id Id of the database to initialize.\n * @param stores Keys of the stores to initialize.\n * @param version Optional: version of the database to initialize.\n * @param idb Optional: custom indexedDB factory\n * @returns Promise resolving with Cache object\n */\nexport async function initCache<S extends Stores>(\n  id: string,\n  stores: StoreKey<S>[],\n  version?: number,\n  idb?: IDBFactory\n) {\n  const db = await initDb(id, stores, version, idb);\n\n  function openStore(store: StoreKey<S>): IDBObjectStore {\n    const tx = db.transaction(store, \"readwrite\");\n    const objectStore = tx.objectStore(store);\n    return objectStore;\n  }\n\n  function set<Store extends StoreKey<S>>(store: Store, key: string, value: S[Store], ignoreResult = false) {\n    const objectStore = openStore(store);\n    const request = objectStore.put(value, key);\n\n    if (ignoreResult) return;\n\n    const [resolve, reject, promise] = deferred<void>();\n\n    request.onerror = (error) => {\n      reject(new Error(JSON.stringify(error)));\n    };\n\n    request.onsuccess = () => {\n      resolve();\n    };\n\n    return promise;\n  }\n\n  function get<Store extends StoreKey<S>>(store: Store, key: string): Promise<S[Store] | undefined> {\n    const [resolve, reject, promise] = deferred<S[Store] | undefined>();\n\n    const objectStore = openStore(store);\n    const request = objectStore.get(key);\n\n    request.onerror = (error) => {\n      reject(new Error(JSON.stringify(error)));\n    };\n\n    request.onsuccess = () => {\n      const item = request.result;\n      resolve(item);\n    };\n\n    return promise;\n  }\n\n  function remove(store: StoreKey<S>, key: string): Promise<void> {\n    const [resolve, reject, promise] = deferred<void>();\n\n    const objectStore = openStore(store);\n    const request = objectStore.delete(key);\n\n    request.onerror = (error) => {\n      reject(new Error(JSON.stringify(error)));\n    };\n\n    request.onsuccess = () => {\n      resolve();\n    };\n\n    return promise;\n  }\n\n  function keys(store: StoreKey<S>): Promise<IterableIterator<string>> {\n    const [resolve, reject, promise] = deferred<IterableIterator<string>>();\n\n    const objectStore = openStore(store);\n    const request = objectStore.getAllKeys();\n\n    request.onerror = (error) => {\n      reject(new Error(JSON.stringify(error)));\n    };\n\n    request.onsuccess = () => {\n      const rawKeys = arrayToIterator(request.result);\n      const stringKeys = transformIterator(rawKeys, (k) => k.toString());\n      resolve(stringKeys);\n    };\n\n    return promise;\n  }\n\n  function values<Store extends StoreKey<S>>(store: Store): Promise<IterableIterator<S[Store]>> {\n    const [resolve, reject, promise] = deferred<IterableIterator<S[Store]>>();\n\n    const objectStore = openStore(store);\n    const request = objectStore.getAll();\n\n    request.onerror = (error) => {\n      reject(new Error(JSON.stringify(error)));\n    };\n\n    request.onsuccess = () => {\n      resolve(arrayToIterator(request.result));\n    };\n\n    return promise;\n  }\n\n  async function entries<Store extends StoreKey<S>>(store: Store): Promise<IterableIterator<[string, S[Store]]>> {\n    const [keyIterator, valueIterator] = await Promise.all([keys(store), values(store)]);\n    return mergeIterators(keyIterator, valueIterator);\n  }\n\n  return { set, get, remove, keys, values, entries, db };\n}\n"],"mappings":"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","names":["arrayToIterator","deferred","mergeIterators","transformIterator","indexedDB","VERSION","initStore","db","storeId","initDb","dbId","stores","version","idb","resolve","reject","promise","request","store","error","initCache","id","openStore","set","key","value","ignoreResult","get","item","remove","keys","rawKeys","stringKeys","k","values","entries","keyIterator","valueIterator"]}