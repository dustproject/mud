var je=Object.defineProperty;var Le=(t,e,o)=>e in t?je(t,e,{enumerable:!0,configurable:!0,writable:!0,value:o}):t[e]=o;var Y=(t,e,o)=>(Le(t,typeof e!="symbol"?e+"":e,o),o);import"phaser";import{deferred as Ee}from"@latticexyz/utils";async function Me(t,e){let[o,,i]=Ee(),{targets:n}=t;if(!(!n.scene||!n.scene.tweens))return e?.keepExistingTweens||X(n),n.scene.tweens.add({...t,onComplete:(s,c)=>{t.onComplete&&t.onComplete(s,c),o()}}),i}function X(t){let e=t.scene.tweens;for(let o of e.tweens)o.hasTarget(t)&&o.stop()}function I(t,e){return(t%e+e)%e}var Re={x:0,y:0};function Ie(t,e){let o=[];return t.forEach(i=>{let n={x:i.x*e,y:i.y*e},s={x:(i.x+1)*e-1,y:i.y*e},c={x:i.x*e,y:(i.y+1)*e-1},r={x:(i.x+1)*e-1,y:(i.y+1)*e-1};o.push(n,s,c,r)}),o}function ze(t,e){return t.x>=e.x&&t.x<e.x+e.width&&t.y>=e.x&&t.y<e.y+e.height}function J(t,e){return!t&&!e?!0:!t||!e?!1:t.x===e.x&&t.y===e.y}function Fe(t,e){return{x:t.x+e.x,y:t.y+e.y}}function z(t,e){return{x:Math.floor(t.x/e),y:Math.floor(t.y/e)}}function W(t,e){return{x:t.x*e,y:t.y*e}}function ue(t,e,o){return{x:Math.floor(t.x/e),y:Math.floor(t.y/o)}}function Z(t,e,o){return{x:t.x*e,y:t.y*o}}function V(t,e,o,i){let n=Z(t,e,o);return z(n,i)}function Q(t,e,o,i){let n=W(t,i);return ue(n,e,o)}import{deferred as De}from"@latticexyz/utils";async function ee(t,e){let o=t.load;e(o),o.start();let[i,,n]=De();return o.on("complete",()=>{i()}),n}import{CoordMap as We}from"@latticexyz/utils";function te(t,e){let o={x:t.x,y:t.y},i={x:t.x+t.width,y:t.y+t.height},n=z(o,e),s=z(i,e),c=s.x-n.x+1,r=s.y-n.y+1,l=new We;for(let d=0;d<c;d++)for(let a=0;a<r;a++)l.set({x:n.x+d,y:n.y+a},!0);return l}function _e(t,e){let o=[];for(let i of t)for(let n of i.getChildren())n.active&&"x"in n&&"y"in n&&e.contains(n.x,n.y)&&(console.log("got one",n),o.push(n));return o.filter(i=>i!==void 0)}function oe(t,e){return e.prefix&&e.suffix?t.generateFrameNames(e.assetKey,{start:e.startFrame,end:e.endFrame,prefix:e.prefix,suffix:e.suffix}):t.generateFrameNumbers(e.assetKey,{start:e.startFrame,end:e.endFrame})}var $e=Phaser.Renderer.WebGL.Pipelines.SpriteFXPipeline||Object,F=class extends $e{_tintColor=new Phaser.Display.Color;_outline=0;_outlineColor=new Phaser.Display.Color;constructor(e){super({game:e,renderTarget:!0,fragShader:`
        precision mediump float;
        uniform sampler2D uMainSampler;
        uniform vec2 uTextureSize;
        uniform vec3 tintColor;
        uniform int outline;
        uniform vec3 outlineColor;
        varying vec2 outTexCoord;
        
        vec3 rgb2hsv(vec3 c)
        {
            vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
            vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
            vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
            float d = q.x - min(q.w, q.y);
            float e = 1.0e-10;
            return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
        }
        
        void main(void)
        {
            vec4 srcColor;
            vec4 outColor;
            vec3 hsvColor;
            vec3 rgbColor;
            srcColor = texture2D(uMainSampler, outTexCoord);
            hsvColor = rgb2hsv(srcColor.rgb);
            if (hsvColor.g == 0.0 && !(tintColor.r == 0.0 && tintColor.g == 0.0 && tintColor.b == 0.0))
            {
              rgbColor = srcColor.rgb * tintColor;
            } else {
              rgbColor = srcColor.rgb;
            }
            outColor = vec4(rgbColor.r, rgbColor.g, rgbColor.b, srcColor.a);
            if(outline == 1) {
              vec2 distance = vec2(2.0, 2.0) / uTextureSize;
              float upAlpha = texture2D(uMainSampler, outTexCoord + vec2(0.0, distance.y)).a;
              float leftAlpha = texture2D(uMainSampler, outTexCoord + vec2(-distance.x, 0.0)).a;
              float downAlpha = texture2D(uMainSampler, outTexCoord + vec2(0.0, -distance.y)).a;
              float rightAlpha = texture2D(uMainSampler, outTexCoord + vec2(distance.x, 0.0)).a;
              if (srcColor.a == 0.0 && max(max(upAlpha, downAlpha), max(leftAlpha, rightAlpha)) == 1.0)
              {
                outColor = vec4(outlineColor, 1.0);
              }
            }
            gl_FragColor = outColor; 
        }
        `})}onDrawSprite(e){let o=e.pipelineData.hueTint,i=e.pipelineData.outline,n=e.pipelineData.outlineColor,s=o||0;if(typeof s=="number"&&(s=Phaser.Display.Color.IntegerToRGB(s)),i){this._outline=1;let c=n??0;typeof c=="number"&&(c=Phaser.Display.Color.IntegerToRGB(n)),this._outlineColor.setFromRGB(c)}else this._outline=0;this._tintColor.setFromRGB(s)}onDraw(e){this.set2f("uTextureSize",this.renderer.width,this.renderer.height),this.set3f("tintColor",this._tintColor.redGL,this._tintColor.greenGL,this._tintColor.blueGL),this.set1i("outline",this._outline),this.set3f("outlineColor",this._outlineColor.redGL,this._outlineColor.greenGL,this._outlineColor.blueGL),this.drawToGame(e)}};Y(F,"KEY","HueTintFXPipeline");var M=class extends Phaser.Renderer.WebGL.Pipelines.MultiPipeline{constructor(e){super({game:e,fragShader:`
        #define SHADER_NAME PHASER_MULTI_V2_FS
        #define numTextures %count%
        precision highp float;
        uniform sampler2D uMainSampler[%count%];
        varying vec2 outTexCoord;
        varying float outTexId;
        varying float outTintEffect;
        varying vec4 outTint;
        
        vec4 getSampler (int index, vec2 uv)
        {
            for (int i = 0; i < numTextures; ++i)
            {
                if (i == index)
                {
                    return texture2D(uMainSampler[i], uv);
                }
            }
        
            //  Return black
            return vec4(0);
        }
        vec3 rgb2hsv(vec3 c)
        {
            vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
            vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
            vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
            float d = q.x - min(q.w, q.y);
            float e = 1.0e-10;
            return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
        }
        vec3 hsv2rgb(vec3 c)
        {
            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
        }
        
        void main ()
        {
            vec4 srcColor;
            vec3 hsvColor;
            vec3 rgbColor;
            vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);
            srcColor = getSampler(int(outTexId), outTexCoord);
            vec4 color = srcColor * texel;
            //  Multiply texture tint
            vec3 hueTintColor = outTint.bgr;
            if (hueTintColor != vec3(0.0, 0.0, 0.0)) {
              hsvColor = rgb2hsv(srcColor.rgb);
              if (hsvColor.g == 0.0 && srcColor.a == 1.)
              {
                vec3 color = hsv2rgb(hsvColor);
                rgbColor = color * hueTintColor;
              } else {
                rgbColor = hsv2rgb(hsvColor);
              }
              color = vec4(rgbColor.r, rgbColor.g, rgbColor.b, srcColor.a);
            }
            gl_FragColor = color;
        }
        `})}};Y(M,"KEY","MultiHueTintPipeline");function me(t){let{preload:e,create:o,update:i,key:n}=t;return class extends Phaser.Scene{constructor(){super({key:n})}preload(){e&&e(this)}create(){o&&o(this);let c=this.renderer;c?.pipelines&&(c.pipelines.add(F.KEY,new F(this.game)),c.pipelines.add(M.KEY,new M(this.game)))}update(){i&&i(this)}}}function de(t){return{type:Phaser.WEBGL,scale:t.scale,pixelArt:!0,autoFocus:!0,render:{antialiasGL:!1,pixelArt:!0},scene:t.scenes}}var pe=(i=>(i[i.Image=0]="Image",i[i.SpriteSheet=1]="SpriteSheet",i[i.MultiAtlas=2]="MultiAtlas",i))(pe||{}),re={Sprite:Phaser.GameObjects.Sprite,Rectangle:Phaser.GameObjects.Rectangle,Line:Phaser.GameObjects.Line,Text:Phaser.GameObjects.Text};import{map as Ve,Subject as fe}from"rxjs";import{CoordMap as qe,subtract as ye}from"@latticexyz/utils";function ne(t,e,o=100){let i={current:new qe},n=new fe,s=new fe;return t.pipe(Ve(({x:r,y:l,width:d,height:a})=>te({x:r-o,y:l-o,width:d+2*o,height:a+2*o},e))).subscribe(r=>{let l=ye(r,i.current);for(let a of l.coords())n.next(a);let d=ye(i.current,r);for(let a of d.coords())s.next(a);i.current=r}),{addedChunks$:n.asObservable(),removedChunks$:s.asObservable(),chunkSize:e,visibleChunks:i}}import{Gesture as Ne}from"@use-gesture/vanilla";import{BehaviorSubject as Ce,filter as He,map as q,sampleTime as Be,scan as Ye,Subject as be,throttleTime as Xe}from"rxjs";function he(t,e){document.addEventListener("gesturestart",m=>m.preventDefault()),document.addEventListener("gesturechange",m=>m.preventDefault());let o=new Ce(t.worldView),i=new Ce(t.zoom),n=new be,s=new be,c=new Ne(t.scene.game.canvas,{onPinch:m=>s.next(m),onWheel:m=>n.next(m)},{}),r=()=>{requestAnimationFrame(()=>o.next(t.worldView))};t.scene.scale.addListener("resize",r);function l(m){t.setZoom(m),o.next(t.worldView),i.next(m)}let d=s.pipe(Xe(10),q(m=>{let x=i.getValue(),k=(m.offset[0]-x)*e.pinchSpeed;return x+k}),q(m=>Math.min(Math.max(m,e.minZoom),e.maxZoom)),Ye((m,x)=>[m[1],x],[1,1])).subscribe(([,m])=>{c._ctrl.state.pinch&&(c._ctrl.state.pinch.offset[0]=m),l(m)}),a=n.pipe(He(m=>!m.pinching),Be(10),q(m=>m.delta.map(x=>x*e.wheelSpeed)),q(m=>m.map(x=>x/t.zoom)),q(m=>[t.scrollX+m[0],t.scrollY+m[1]])).subscribe(([m,x])=>{t.setScroll(m,x),o.next(t.worldView)});function v(m,x){m.ignoreCamera(t.id,x)}function P(m,x,u){let k=Z(m,x,u);y(k.x,k.y)}function y(m,x){t.centerOn(m,x),requestAnimationFrame(()=>o.next(t.worldView))}function h(m,x){t.setScroll(m,x),requestAnimationFrame(()=>o.next(t.worldView))}return{phaserCamera:t,worldView$:o,zoom$:i,ignore:v,dispose:()=>{d.unsubscribe(),a.unsubscribe(),c.destroy(),t.scene.scale.removeListener("resize",r)},centerOnCoord:P,centerOn:y,setScroll:h,setZoom:l}}import{computed as Ze,observe as Ue,reaction as Je}from"mobx";import{from as Qe,map as xe,mergeMap as et,pipe as tt}from"rxjs";import{filterNullish as ot}from"@latticexyz/utils";import{CoordMap as rt}from"@latticexyz/utils";function nt(){let t=new rt,e=new Map;function o(s){let c=t.get(s);return c||(c=new Set,t.set(s,c)),c}function i(s,c){let r=e.get(s);(r&&o(r))?.delete(s),o(c).add(s),e.set(s,c)}function n(s){let c=e.get(s);(c&&o(c))?.delete(s),e.delete(s)}return{set:i,remove:n,get:o}}function ge(t,e,o){let i=nt(),n=new Map,s=tt(xe(a=>Qe(i.get(a))),et(a=>a),xe(a=>t.get(a,"Existing")),ot()),c=o.addedChunks$.pipe(s).subscribe(a=>a.spawn()),r=o.removedChunks$.pipe(s).subscribe(a=>a.despawn());function l(a){n.get(a.id)&&console.error("Entity is being tracked multiple times",a);let v=Ze(()=>z(a.position,o.chunkSize),{equals:J}),P=Je(()=>v.get(),y=>{i.set(a.id,y),o.visibleChunks.current.get(y)?a.spawn():a.despawn()},{fireImmediately:!0});n.set(a.id,P)}let d=Ue(t.objects,a=>{if(a.type==="add"&&l(a.newValue),a.type==="delete"){i.remove(a.oldValue.id);let v=n.get(a.oldValue.id);v&&v(),n.delete(a.oldValue.id)}});return{dispose:()=>{for(let a of n.values())a();d(),c.unsubscribe(),r.unsubscribe()}}}import{observable as it,runInAction as ve}from"mobx";function Co(t){return t}function bo(t){return t}function ho(t){return t}function xo(t){return t}function go(t){return t}function ie(t,e){return e==="Sprite"}function Te(t,e){return e==="Rectangle"}function Pe(t,e,o,i=0){let n=it({x:0,y:0}),s=new Map,c=new Map,r,l={current:i};function d(u){return we(u)?k=>{u(k),ve(()=>{n.x=k.x,n.y=k.y})}:u}async function a({id:u,now:k,once:C,update:b}){let w=C&&we(C);w&&ve(()=>{n.x=w.x??n.x,n.y=w.y??n.y}),C&&s.set(u,d(C)),b&&c.set(u,d(b)),r&&k&&await d(k)(r),r&&C&&C(r)}function v(u){return s.has(u)||c.has(u)}function P(u,k){s.delete(u),c.delete(u),r&&(y(r,k),ke(r,s.values()))}function y(u,k=!0){k&&(ie(u,o)&&u.stop(),X(u)),u.setDepth(10),u.cameraFilter=l.current,u.resetPipeline(!0,!0),u.setScale(1,1),u.setOrigin(0,0),u.setAlpha(1),u.setScrollFactor(1),u.clearMask(),u.setData("objectPoolId",null),ie(u,o)&&(u.clearTint(),u.setTexture("")),Te(u,o)&&(u.width=0,u.height=0)}function h(u){l.current=u,r&&(r.cameraFilter=u)}function m(){if(r)return;let u=e.get();y(u),ke(u,s.values()),u.setActive(!0),u.setVisible(!0),u.setData("objectPoolId",t),r=u}function x(){r&&e.killAndHide(r),r=void 0}return{setComponent:a,hasComponent:v,removeComponent:P,spawn:m,despawn:x,position:n,id:t,setCameraFilter:h,type:o}}function ke(t,e){if(t)for(let o of e)o(t)}function we(t){let e,o=new Proxy({x:void 0,y:void 0},{get:(i,n)=>n==="setPosition"?(s,c)=>e={x:s,y:c}:n==="setX"?s=>e={x:s}:n==="setY"?s=>e={y:s}:()=>{},set:(i,n,s)=>(n==="x"&&(e=e?{...e,x:s}:{x:s}),n==="y"&&(e=e?{...e,y:s}:{y:s}),!0)});return t(o),e}import{observable as st}from"mobx";import{mapObject as at}from"@latticexyz/utils";function ct(t){return Object.keys(re).includes(t)}function Se(t){let e=at(re,r=>t.add.group({classType:r})),o=st(new Map),i={current:0};function n(r,l){typeof r=="number"&&(r=String(r));let d=o.get(r);return ct(l)?(d||(d=Pe(r,e[l],l,i.current)),o.has(r)||o.set(r,d),d):d||void 0}function s(r){typeof r=="number"&&(r=String(r));let l=o.get(r);l&&l.despawn(),o.delete(r)}function c(r,l){l?i.current|=r:i.current&=~r;for(let d of o.values())d.setCameraFilter(i.current)}return{get:n,remove:s,objects:o,groups:e,ignoreCamera:c}}import{CoordMap as lt}from"@latticexyz/utils";import{pickRandom as ut}from"@latticexyz/utils";function se(t){let{scene:e,tilesets:o,layerConfig:i,chunks:n,backgroundTile:s,tiles:c,tileWidth:r,tileHeight:l}=t,d=Object.keys(i.layers).map(f=>i.layers[f].tilesets).flat();if(I(n.chunkSize,r)!==0||I(n.chunkSize,l)!==0)throw new Error("Chunks pixel size must be a multiple of tile width and height to be used with chunked tilemap");let a=new lt,v={x:n.chunkSize/r,y:n.chunkSize/l},P=new Set,y={current:!0};for(let f of n.visibleChunks.current.coords())p(f);let h=n.addedChunks$.subscribe(f=>{p(f)}),m=n.removedChunks$.subscribe(f=>{b(f)});P.add(()=>h?.unsubscribe()),P.add(()=>m?.unsubscribe);function x(f,T,S,O,K,G){let L={};for(let E of Object.keys(i.layers)){let H=i.layers[E],$=f.createBlankLayer(E,H.tilesets.map(U=>o[U]),S,O,K,G);if(!$){console.error(`Adding tilemap layer ${E} failed.`);continue}L[E]=$;let B=T.game.renderer;H.hasHueTintShader&&B?.pipelines&&(L[E].pipeline=B.pipelines.get(M.KEY))}return{layers:Object.values(L),defaultLayer:L[i.defaultLayer]}}function u(f){let T=new Phaser.Tilemaps.MapData({tileHeight:l,tileWidth:r,width:v.x,height:v.y,tilesets:Object.entries(o).filter(([G])=>d.includes(G)).map(([,G])=>G)}),S=new Phaser.Tilemaps.Tilemap(e,T),O=W(f,n.chunkSize),{defaultLayer:K}=x(S,e,O.x,O.y,v.x,v.y);return S.setLayer(K),a.set(f,S),S}function k(f){return a.get(f)||u(f)}function C(f){let T=V(f,r,l,n.chunkSize);return k(T)}function b(f,T){if(!y.current&&!T||!a.has(f))return;k(f).destroy(),a.delete(f)}function w(f,T,S,O){if(!y.current)return;let K=C(f),G=K.putTileAt(T,I(f.x,v.x),I(f.y,v.y),void 0,S);if(G==null)throw new Error("putTileAt failed");G.width=K.tileWidth,G.height=K.tileHeight,O&&(G.tint=O)}function p(f){if(!y.current)return;let T=k(f),S=Q(f,r,l,n.chunkSize);for(let O of Object.keys(i.layers))T.forEachTile(K=>{let G={x:S.x+K.x,y:S.y+K.y},L=O===i.defaultLayer?ut(s):-1,E=c[O].get(G)||L;K.index=E},void 0,void 0,void 0,void 0,void 0,void 0,O)}function g(){for(let f of a.values())f.destroy();a.clear();for(let f of P)f()}function A(){return a.size}function _(f){if(f!==y.current){y.current=f;for(let T of n.visibleChunks.current.coords())y.current?p(T):b(T,!0)}}return{size:A,putTileAt:w,dispose:g,setVisible:_,visible:y,tileWidth:r,tileHeight:l}}import{CoordMap as mt}from"@latticexyz/utils";function ae(t){let{chunks:e,layerConfig:{layers:o,defaultLayer:i},tileWidth:n,tileHeight:s}=t,c={};for(let d of Object.keys(o))c[d]=new mt;let r=se({...t,tiles:c});function l(d,a,v,P){c[v||i].set(d,a);let y=V(d,n,s,e.chunkSize);r.visible&&e.visibleChunks.current.get(y)&&r.putTileAt(d,a,v,P)}return{...r,putTileAt:l,tiles:c}}import{CoordMap as Ae}from"@latticexyz/utils";function ce(t){let{layerConfig:{layers:e,defaultLayer:o},animationInterval:i,scene:n}=t,s=o,c=0,r={},l={};for(let C of Object.keys(e))l[C]=new Ae;let d={};for(let C of Object.keys(e))d[C]=new Ae;let a=ae(t);function v(C,b){r[C]={frames:b,index:0}}function P(C,b,w=s){l[w].set(C,b)}function y(C,b=s){let w=l[b].get(C),p=w&&r[w];l[b].delete(C),p&&a.putTileAt(C,p.frames[0],b)}function h(C,b=s){let w=l[b].get(C);w&&(d[b].set(C,w),y(C,b))}function m(C,b=s){let w=d[b].get(C);w&&(d[b].delete(C),P(C,w,b))}function x(){for(let C of Object.keys(r)){let b=r[C];b&&(b.index=I(b.index+1,b.frames.length))}for(let C of Object.keys(l)){let b=l[C];for(let w of b.coords()){let p=b.get(w),g=p&&r[p];if(!g)continue;let A=g.frames[g.index];a.putTileAt(w,A,C)}}}function u(C){C<c+i||(c=C,x())}function k(){n.events.removeListener("update",u),a.dispose()}return n.events.addListener("update",u),{...a,putAnimationAt:P,removeAnimationAt:y,pauseAnimationAt:h,resumeAnimationAt:m,registerAnimation:v,dispose:k}}import{bufferCount as Ke,distinctUntilChanged as dt,filter as j,fromEvent as le,map as R,merge as N,pairwise as pt,scan as ft,Subject as yt,throttleTime as Ct}from"rxjs";import{observable as bt,reaction as ht,runInAction as Oe}from"mobx";import{filterNullish as D}from"@latticexyz/utils";function Ge(t){let e=new Set,o={current:!0};t.mouse?.disableContextMenu();function i(){o.current=!1}function n(){o.current=!0}function s(p){t.setDefaultCursor(p)}let c=new yt,r=le(document,"mousemove").pipe(j(()=>o.current),R(()=>({pointer:t.manager?.activePointer})),D()),l=le(document,"mousedown").pipe(j(()=>o.current),R(p=>({pointer:t.manager?.activePointer,event:p})),D()),d=le(document,"mouseup").pipe(j(()=>o.current),R(p=>({pointer:t.manager?.activePointer,event:p})),D()),a=N(l,d).pipe(j(()=>o.current),R(({event:p})=>[p.type==="mousedown"&&p.button===0,Date.now()]),Ke(2,1),j(([p,g])=>p[0]&&!g[0]&&g[1]-p[1]<250),R(()=>t.manager?.activePointer),D()),v=l.pipe(j(()=>o.current),R(()=>Date.now()),Ke(2,1),j(([p,g])=>g-p<500),Ct(500),R(()=>t.manager?.activePointer),D()),P=N(l,d).pipe(j(({pointer:p})=>o.current&&p.rightButtonDown()),R(()=>t.manager?.activePointer),D()),y=N(l.pipe(R(()=>{})),N(d,r).pipe(pt(),ft((p,[{pointer:g},{pointer:A}])=>A.leftButtonDown()?g.leftButtonDown()&&p?{...p,width:A.worldX-p.x,height:A.worldY-p.y}:{x:A.worldX,y:A.worldY,width:0,height:0}:void 0,void 0),D(),j(p=>Math.abs(p.width)>10&&Math.abs(p.height)>10))).pipe(j(()=>o.current),dt()),h=bt(new Set),m=t.keyboard,x=new Map;for(let p of Object.keys(Phaser.Input.Keyboard.KeyCodes))C(p);let u=c.pipe(j(()=>o.current)).subscribe(p=>{let g=x.get(p.keyCode);g&&Oe(()=>{p.isDown&&h.add(g),p.isUp&&h.delete(g)})});e.add(()=>u?.unsubscribe());let k=N(l,d).subscribe(({pointer:p})=>{Oe(()=>{p.leftButtonDown()?h.add("POINTER_LEFT"):h.delete("POINTER_LEFT"),p.rightButtonDown()?h.add("POINTER_RIGHT"):h.delete("POINTER_RIGHT")})});e.add(()=>k?.unsubscribe());function C(p){if(!m){console.warn(`Adding key ${p} failed. No phaser keyboard detected.`);return}let g=m.addKey(p,!1);x.set(g.keyCode,p),g.removeAllListeners(),g.emitOnRepeat=!0,g.on("down",A=>c.next(A)),g.on("up",A=>c.next(A))}function b(p,g){let A=ht(()=>p(h),_=>{_&&g()},{fireImmediately:!0});e.add(A)}function w(){for(let p of e)p()}return{keyboard$:c.asObservable(),pointermove$:r,pointerdown$:l,pointerup$:d,click$:a,doubleClick$:v,rightClick$:P,drag$:y,pressedKeys:h,dispose:w,disableInput:i,enableInput:n,setCursor:s,enabled:o,onKeyPress:b}}import{deferred as xt}from"@latticexyz/utils";async function dr(t){let{scale:e,sceneConfig:o,cameraConfig:i,cullingChunkSize:n}=t,s=Object.keys(o).map(y=>{let{preload:h,create:m,update:x}=o[y];return me({key:y,preload:h,create:m,update:x})}),c=de({scenes:s,scale:e}),r=new Phaser.Game(c),[l,,d]=xt();r.events.on("ready",l),c.type===Phaser.HEADLESS&&r.textures.emit("ready"),await d;function a(){let y=window.innerWidth/r.scale.zoom,h=window.innerHeight/r.scale.zoom;r.scale.resize(y,h)}a(),window.addEventListener("resize",a);let v={};for(let y of r.scene.getScenes(!1)){let h=y.scene.key,m=o[h];for(let[f,T]of Object.entries(o[h].assets))await ee(y,S=>{T.type===0?S.image(f,T.path):T.type===1?S.spritesheet(f,T.path,T.options):T.type===2&&S.multiatlas(f,T.path,T.options.imagePath)});let x=Se(y),u=he(y.cameras.main,i),k=ne(u.worldView$,n),C=ge(x,u,k);for(let f of m.animations)y.anims.create({key:f.key,frames:oe(y.anims,f),frameRate:f.frameRate,repeat:f.repeat});let b=new Phaser.Tilemaps.Tilemap(y,new Phaser.Tilemaps.MapData),w={};for(let[f,{assetKey:T,tileWidth:S,tileHeight:O}]of Object.entries(o[h].tilesets)){let K=b.addTilesetImage(f,T,S,O);if(!K){console.error(`Adding tileset ${f} failed.`);continue}w[f]=K}let p=w,g={};for(let f of Object.keys(m.maps)){let{layers:T,backgroundTile:S,tileWidth:O,tileHeight:K,animationInterval:G,tileAnimations:L,chunkSize:E}=m.maps[f],H=ne(u.worldView$,E),$=ce({scene:y,tilesets:p,layerConfig:T,chunks:H,tileWidth:O,tileHeight:K,backgroundTile:S,animationInterval:G});if(L)for(let[B,U]of Object.entries(L))$.registerAnimation(B,U);g[f]=$}let A=g,_=Ge(y.input);v[h]={phaserScene:y,objectPool:x,camera:u,culling:C,maps:A,input:_,config:o[h]}}let P=v;return{game:r,scenes:P,dispose:()=>{r.destroy(!0);for(let y of Object.keys(P)){let h=P[y];h.camera.dispose(),h.culling.dispose(),h.input.dispose();for(let m of Object.values(h.maps))m.dispose()}window.removeEventListener("resize",a)}}}import{CoordMap as gt}from"@latticexyz/utils";function Tt(){let t=Math.random()*255,e=Math.random()*255,o=Math.random()*255;return t*65535+e*255+o}function Cr(t,e,o,i,n){let s={logViewport:!1,visualizeChunks:!0,visualizeViewport:!1,logNumVisibleChunks:!1,logObjectStats:!1,logMaps:!0},c=new gt,r=o.add.rectangle(0,0,1,1,16711680,.2);r.setInteractive(),r.on("pointerup",()=>{console.log("clicked",r)}),t.worldView$.subscribe(l=>{s.logViewport&&console.log(l),s.visualizeViewport&&(r.setScale(l.width,l.height),r.setPosition(l.centerX,l.centerY)),s.logObjectStats&&console.log(`Entities: ${i.objects.size} / Pool size: ${Object.values(i.groups).reduce((d,a)=>d+a.getChildren().length,0)} / Pool active: ${Object.values(i.groups).reduce((d,a)=>d+a.countActive(),0)}`),s.logMaps&&console.log("Num maps",n.size())}),e.addedChunks$.subscribe(l=>{if(s.visualizeChunks){let d=W(l,e.chunkSize),a=o.add.rectangle(d.x+e.chunkSize/2,d.y+e.chunkSize/2,e.chunkSize,e.chunkSize,Tt(),.5);a.setInteractive(),a.on("pointerup",()=>{console.log("clicked",a)}),c.set(l,a)}s.logNumVisibleChunks&&console.log("Number of visible chunks: ",c.size)}),e.removedChunks$.subscribe(l=>{s.visualizeChunks&&(c.get(l)?.destroy(),c.delete(l)),s.logNumVisibleChunks&&console.log("Number of visible chunks: ",c.size)})}export{pe as AssetType,re as GameObjectClasses,F as HueTintAndOutlineFXPipeline,M as MultiHueTintPipeline,Re as ZERO_VECTOR,Fe as addCoords,Q as chunkCoordToTileCoord,W as chunkToPixelCoord,J as coordEq,Ie as cornerTileCoordsFromRegionCoords,ce as createAnimatedTilemap,he as createCamera,se as createChunkedTilemap,ne as createChunks,ge as createCulling,Cr as createDebugger,Ge as createInput,Se as createObjectPool,dr as createPhaserEngine,ae as createVirtualTilemap,Co as defineAssetsConfig,go as defineCameraConfig,bo as defineMapConfig,de as definePhaserConfig,xo as defineScaleConfig,me as defineScene,ho as defineSceneConfig,oe as generateFrames,te as getChunksInArea,_e as getObjectsInArea,Te as isRectangle,ie as isSprite,ze as isTileInArea,ee as load,I as mod,ue as pixelCoordToTileCoord,z as pixelToChunkCoord,X as removeAllTweens,V as tileCoordToChunkCoord,Z as tileCoordToPixelCoord,Me as tween};
//# sourceMappingURL=index.mjs.map